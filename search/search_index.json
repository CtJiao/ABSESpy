{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"index","text":"<p>Date: October 19, 2023, Version: 0.2.0.alpha</p> <p>Useful links: Install | Source Repository | Issues &amp; Ideas | Q&amp;A Support | Mailing List</p> <p><code>ABSESpy</code> is an Agent-Based modeling (ABM) framework that makes modeling artificial Social-ecological systems (SES) easier.</p> <p>Pure beginner of ABM or SES</p> <p>Know basic ideas but don't know how to start</p> <p>Source code and API documentation</p> <p>Check out the tutorials</p>"},{"location":"materials/","title":"Reading materials & introductory tutorials","text":""},{"location":"materials/#reading-materials-introductory-tutorials","title":"Reading materials &amp; introductory tutorials","text":""},{"location":"materials/#agent-based-model","title":"Agent-based model","text":"<ul> <li>Introduction of Agent-based Modeling</li> </ul>"},{"location":"materials/#developers","title":"Developers","text":"<ul> <li><code>Pytest</code> awesome plugins</li> </ul>"},{"location":"navigation/","title":"Navigation","text":""},{"location":"navigation/#navigation","title":"Navigation","text":"<p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p>"},{"location":"navigation/#about","title":"About","text":"<ul> <li>Is <code>ABSESpy</code> for me?</li> <li>Highlight features</li> <li>Installment of <code>ABSESpy</code></li> <li>Dependencies</li> <li>Acknowledgment</li> <li>License</li> </ul>"},{"location":"navigation/#wiki","title":"Wiki","text":"<ul> <li>Context of the ABSESpy</li> <li>Basic terms and definitions</li> </ul>"},{"location":"navigation/#tutorials","title":"Tutorials","text":"<ul> <li>beginner<ul> <li>run a model from the examples</li> <li>write your first artificial SES model</li> <li>try different parameters</li> </ul> </li> <li>advanced<ul> <li>visualize your model</li> <li>use add-in package modules</li> <li>setup dynamic variables</li> <li>batch run and experiment</li> </ul> </li> <li>lessons<ul> <li>Design structure</li> </ul> </li> </ul>"},{"location":"navigation/#examples","title":"Examples","text":"<ul> <li>Example Gallery</li> </ul>"},{"location":"navigation/#packages","title":"Packages","text":"<ul> <li>Add-in agent modules</li> <li>Add-in nature modules</li> <li>Add-in human modules</li> </ul>"},{"location":"navigation/#contribution","title":"Contribution","text":"<p>There are several ways to contribute to <code>ABSESpy</code> -bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome:</p> <ul> <li>Discuss in the community</li> <li>Feature suggestions and bug report</li> <li>Code or docs contribution</li> <li>Sharing module package</li> <li>Upload model example</li> </ul>"},{"location":"navigation/#api-references","title":"API References","text":"<ul> <li>Time Control</li> </ul>"},{"location":"api/agents/","title":"Actor (Agent)","text":"<p>             Bases: <code>GeoAgent</code>, <code>_BaseObj</code>, <code>LinkNode</code></p> <p>An actor in a social-ecological system (or \"Agent\" in an agent-based model.)</p> <p>Attributes:</p> Name Type Description <code>container</code> <p>The container that the actor belongs to.</p> <code>layer</code> <code>RasterLayer</code> <p>The layer where the actor is located.</p> <code>indices</code> <code>Coordinate</code> <p>The indices of the cell where the actor is located.</p> <code>pos</code> <code>Coordinate</code> <p>The position of the cell where the actor is located.</p> <code>population</code> <code>ActorsList</code> <p>A list of actors of the same breed as the actor.</p> <code>on_earth</code> <code>bool</code> <p>Whether the actor is standing on a cell.</p> <code>here</code> <code>ActorsList</code> <p>A list of actors that are on the same cell as the actor.</p> <p>Methods:</p> Name Description <code>put_on</code> <p>PatchCell | None = None) -&gt; None Places the actor on a cell.</p> <code>put_on_layer</code> <p>mg.RasterLayer, pos: Tuple[int, int]) Specifies a new cell for the actor to be located on.</p> <code>selecting</code> <p>Union[str, Dict[str, Any]]) -&gt; bool Selects the actor according to specified criteria.</p> Source code in <code>abses/actor.py</code> <pre><code>def __init__(\n    self,\n    model: MainModel,\n    observer: bool = True,\n    unique_id: Optional[int] = None,\n    **kwargs,\n) -&gt; None:\n    _BaseObj.__init__(self, model, observer=observer)\n    if not unique_id:\n        unique_id = self.model.next_id()\n    crs = kwargs.pop(\"crs\", model.nature.crs)\n    geometry = kwargs.pop(\"geometry\", None)\n    mg.GeoAgent.__init__(\n        self, unique_id, model=model, geometry=geometry, crs=crs\n    )\n    LinkNode.__init__(self)\n    self._rules: Dict[str, Dict[str, Any]] = {}\n    self._cell: PatchCell = None\n    self.container = model.human\n    self._decisions = self._setup_decisions()\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.decisions","title":"decisions  <code>property</code>","text":"<pre><code>decisions\n</code></pre> <p>Decisions that this agent makes.</p>"},{"location":"api/agents/#abses.actor.Actor.layer","title":"layer  <code>property</code>","text":"<pre><code>layer\n</code></pre> <p>Get the layer where the agent is located.</p>"},{"location":"api/agents/#abses.actor.Actor.indices","title":"indices  <code>property</code>","text":"<pre><code>indices\n</code></pre> <p>Coordinates in the form of (row, col) are used for indexing a matrix, with the origin at the top left corner and increasing downwards.</p>"},{"location":"api/agents/#abses.actor.Actor.pos","title":"pos  <code>property</code> <code>writable</code>","text":"<pre><code>pos\n</code></pre> <p>Coordinates in the form of (x, y) indexed from the bottom left corner.</p>"},{"location":"api/agents/#abses.actor.Actor.population","title":"population  <code>property</code>","text":"<pre><code>population\n</code></pre> <p>List of agents of the same breed</p>"},{"location":"api/agents/#abses.actor.Actor.on_earth","title":"on_earth  <code>property</code>","text":"<pre><code>on_earth\n</code></pre> <p>Whether agent stands on a cell</p>"},{"location":"api/agents/#abses.actor.Actor.here","title":"here  <code>property</code>","text":"<pre><code>here\n</code></pre> <p>Other agents on the same cell as the agent.</p>"},{"location":"api/agents/#abses.actor.Actor.put_on","title":"put_on","text":"<pre><code>put_on(cell=None)\n</code></pre> <p>Place agent on a cell. If the agent is already located at a cell, it should be located to a cell with the same layer.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>PatchCell | None</code> <p>The cell where the agent is to be located. If None (default), remove the subject from the current layer.</p> <code>None</code> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the agent is to be moved between different layers.</p> <code>TypeError</code> <p>If the agent is to be put on a non-PatchCell object.</p> Source code in <code>abses/actor.py</code> <pre><code>def put_on(self, cell: PatchCell | None = None) -&gt; None:\n    \"\"\"Place agent on a cell. If the agent is already located at a cell, it should be located to a cell with the same layer.\n\n    Parameters:\n        cell:\n            The cell where the agent is to be located. If None (default), remove the subject from the current layer.\n\n    Raises:\n        IndexError:\n            If the agent is to be moved between different layers.\n        TypeError:\n            If the agent is to be put on a non-PatchCell object.\n    \"\"\"\n    if cell is None:\n        # Remove agent\n        self._cell = None\n        return\n    if self.layer and self.layer is not cell.layer:\n        raise IndexError(\n            f\"Trying to move actor between different layers: from {self.layer} to {cell.layer}\"\n        )\n    if not isinstance(cell, mg.Cell):\n        raise TypeError(\n            f\"Actor must be put on a PatchCell, instead of {type(cell)}\"\n        )\n    if self.on_earth:\n        self._cell.remove(self)\n        self._cell = None\n    cell.add(self)\n    self._cell = cell\n    self.geometry = Point(cell.layer.transform * cell.indices)\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.put_on_layer","title":"put_on_layer","text":"<pre><code>put_on_layer(layer, pos)\n</code></pre> <p>Specifies a new cell for the agent to be located on.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>RasterLayer</code> <p>The layer where the agent is to be located.</p> required <code>pos</code> <code>Tuple[int, int]</code> <p>The position of the cell where the agent is to be located.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the layer is not a valid RasterLayer type.</p> Source code in <code>abses/actor.py</code> <pre><code>def put_on_layer(\n    self, layer: mg.RasterLayer, pos: Tuple[int, int]\n) -&gt; None:\n    \"\"\"Specifies a new cell for the agent to be located on.\n\n    Parameters:\n        layer:\n            The layer where the agent is to be located.\n        pos:\n            The position of the cell where the agent is to be located.\n\n    Raises:\n        TypeError:\n            If the layer is not a valid RasterLayer type.\n    \"\"\"\n    if not isinstance(layer, mg.RasterLayer):\n        raise TypeError(f\"{layer} is not mg.RasterLayer.\")\n    cell = layer.cells[pos[0]][pos[1]]\n    self.put_on(cell=cell)\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.selecting","title":"selecting","text":"<pre><code>selecting(selection)\n</code></pre> <p>Either select the agent according to specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Union[str, Dict[str, Any]]</code> <p>Either a string or a dictionary of key-value pairs that represent agent attributes to be checked against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the agent is selected or not</p> Source code in <code>abses/actor.py</code> <pre><code>def selecting(self, selection: Union[str, Dict[str, Any]]) -&gt; bool:\n    \"\"\"Either select the agent according to specified criteria.\n\n    Parameters:\n        selection:\n            Either a string or a dictionary of key-value pairs that represent agent attributes to be checked against.\n\n    Returns:\n        Whether the agent is selected or not\n    \"\"\"\n    if isinstance(selection, str):\n        selection = parsing_string_selection(selection)\n    results = []\n    for k, v in selection.items():\n        attr = getattr(self, k, None)\n        if attr is None:\n            results.append(False)\n        elif attr == v or str(attr) == v:\n            results.append(True)\n        else:\n            results.append(False)\n    return all(results)\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.die","title":"die","text":"<pre><code>die()\n</code></pre> <p>Kills the agent (self)</p> Source code in <code>abses/actor.py</code> <pre><code>def die(self) -&gt; None:\n    \"\"\"Kills the agent (self)\"\"\"\n    self.model.agents.remove(self)\n    for link in self.links:\n        self.container.get_graph(link).remove_node(self)\n    if self.on_earth:\n        self._cell.remove(self)\n        del self\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.move_to","title":"move_to","text":"<pre><code>move_to(position)\n</code></pre> <p>Move agent to a new position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Optional[Coordinate]</code> <p>The new position to move to.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>The main body is not on the same layer, please use the put_on method first.</p> Source code in <code>abses/actor.py</code> <pre><code>def move_to(self, position: Optional[Coordinate]) -&gt; bool:\n    \"\"\"Move agent to a new position.\n\n    Parameters:\n        position:\n            The new position to move to.\n\n    Raises:\n        ValueError:\n            The main body is not on the same layer, please use the put_on method first.\n    \"\"\"\n    if not self.layer:\n        raise ValueError(\"Layer is not set.\")\n    self.layer.move_agent(self, position)\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.loc","title":"loc","text":"<pre><code>loc(attribute)\n</code></pre> <p>Get attribute data for the cell where the actor is located.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <p>str The name of the attribute to get.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute is not found in the cell where this agent is located.</p> <code>ABSESpyError</code> <p>The agent is not in the environment.</p> Source code in <code>abses/actor.py</code> <pre><code>def loc(self, attribute: str) -&gt; Any:\n    \"\"\"Get attribute data for the cell where the actor is located.\n\n    Parameters:\n        attribute : str\n            The name of the attribute to get.\n\n    Raises:\n        AttributeError:\n            If the attribute is not found in the cell where this agent is located.\n        ABSESpyError:\n            The agent is not in the environment.\n    \"\"\"\n    if self.on_earth:\n        return self._cell.get_attr(attribute)\n    raise ABSESpyError(\n        f\"You should locate this agent ({self}) to somewhere before get associated attribute.\"\n    )\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.alter_nature","title":"alter_nature","text":"<pre><code>alter_nature(attr, value)\n</code></pre> <p>Alter the nature of the parameters of the cell where the actor is located.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the parameter to change.</p> required <code>value</code> <code>Any</code> <p>The new value to assign to the parameter.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute is not found in the cell.</p> Source code in <code>abses/actor.py</code> <pre><code>def alter_nature(self, attr: str, value: Any) -&gt; None:\n    \"\"\"Alter the nature of the parameters of the cell where the actor is located.\n\n    Parameters:\n        attr:\n            The name of the parameter to change.\n        value:\n            The new value to assign to the parameter.\n\n    Raises:\n        AttributeError:\n            If the attribute is not found in the cell.\n    \"\"\"\n    if attr not in self._cell.attributes:\n        raise AttributeError(f\"Attribute {attr} not found.\")\n    setattr(self._cell, attr, value)\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.linked","title":"linked","text":"<pre><code>linked(link)\n</code></pre> <p>Get all other actors linked to this actor.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>The link to search for.</p> required <p>Returns:</p> Type Description <code>ActorsList</code> <p>A list of all actors linked to this actor.</p> Source code in <code>abses/actor.py</code> <pre><code>def linked(self, link: str) -&gt; ActorsList:\n    \"\"\"Get all other actors linked to this actor.\n\n    Parameters:\n        link:\n            The link to search for.\n\n    Returns:\n        A list of all actors linked to this actor.\n    \"\"\"\n    return ActorsList(self.model, super().linked(link))\n</code></pre>"},{"location":"api/cells/","title":"agents","text":"<p>             Bases: <code>Cell</code>, <code>LinkNode</code></p> <p>A patch cell of a <code>RasterLayer</code>.</p> <p>Attributes:</p> Name Type Description <code>agents</code> <code>ActorsList[Actor]</code> <p>The agents located at here.</p> <code>layer</code> <code>PatchModule</code> <p>The <code>RasterLayer</code> where this <code>PatchCell</code> belongs.</p> Source code in <code>abses/cells.py</code> <pre><code>def __init__(self, pos=None, indices=None):\n    mg.Cell.__init__(self, pos, indices)\n    LinkNode.__init__(self)\n    self._agents = {}\n    self._layer = None\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.layer","title":"layer  <code>property</code> <code>writable</code>","text":"<pre><code>layer\n</code></pre> <p><code>RasterLayer</code> where this <code>PatchCell</code> belongs.</p>"},{"location":"api/cells/#abses.cells.PatchCell.breed","title":"breed  <code>classmethod</code> <code>property</code>","text":"<pre><code>breed\n</code></pre> <p>Breed of this <code>PatchCell</code></p>"},{"location":"api/cells/#abses.cells.PatchCell.agents","title":"agents  <code>property</code>","text":"<pre><code>agents\n</code></pre> <p>The agents located at here.</p>"},{"location":"api/cells/#abses.cells.PatchCell.has_agent","title":"has_agent","text":"<pre><code>has_agent(breed=None)\n</code></pre> <p>Whether the actor is standing at the current <code>PatchCell</code>.</p> <p>Parameters:</p> Name Type Description Default <code>breed</code> <code>Optional[str]</code> <p>Specify the breed of agents to search. If None (by default), all breeds of agents are acceptable.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if there is a qualified principal there, False otherwise.</p> Source code in <code>abses/cells.py</code> <pre><code>def has_agent(self, breed: Optional[str] = None) -&gt; bool:\n    \"\"\"Whether the actor is standing at the current `PatchCell`.\n\n    Parameters:\n        breed:\n            Specify the breed of agents to search. If None (by default), all breeds of agents are acceptable.\n\n    Returns:\n        bool:\n            True if there is a qualified principal there, False otherwise.\n    \"\"\"\n    return bool(self._agents) if breed is None else breed in self._agents\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name)\n</code></pre> <p>Gets the value of an attribute or registered property. Automatically update the value if it is the dynamic variable of the layer.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The name of attribute to get.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value of the attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Attribute value of the associated patch cell.</p> Source code in <code>abses/cells.py</code> <pre><code>def get_attr(self, attr_name: str) -&gt; Any:\n    \"\"\"Gets the value of an attribute or registered property. Automatically update the value if it is the dynamic variable of the layer.\n\n    Parameters:\n        attr_name:\n            The name of attribute to get.\n\n    Returns:\n        Any:\n            The value of the attribute.\n\n    Raises:\n        AttributeError:\n            Attribute value of the associated patch cell.\n    \"\"\"\n    if attr_name in self.layer.dynamic_variables:\n        self.layer.dynamic_var(attr_name=attr_name)\n    if not hasattr(self, attr_name):\n        raise AttributeError(f\"{attr_name} not exists in {self.layer}.\")\n    return getattr(self, attr_name)\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.add","title":"add","text":"<pre><code>add(agent)\n</code></pre> <p>Adds an <code>Actor</code> to here.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Actor</code> <p>The <code>Actor</code> to be added.</p> required <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the actor is already on earth (at another cell or another layer).</p> Source code in <code>abses/cells.py</code> <pre><code>def add(self, agent: Actor) -&gt; None:\n    \"\"\"Adds an `Actor` to here.\n\n    Parameters:\n        agent:\n            The `Actor` to be added.\n\n    Raises:\n        ABSESpyError:\n            If the actor is already on earth (at another cell or another layer).\n    \"\"\"\n    if agent.on_earth:\n        raise ABSESpyError(f\"{agent} is already on earth.\")\n    if not issubclass(agent.__class__, Actor):\n        raise TypeError(\n            f\"The agent to be added should be an instance of 'Actor' or its subclass, not {type(agent)}.\"\n        )\n    if agent.breed not in self._agents:\n        self._agents[agent.breed] = {agent}\n    else:\n        self._agents[agent.breed].add(agent)\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.remove","title":"remove","text":"<pre><code>remove(agent)\n</code></pre> <p>Removes an Actor here.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Actor</code> <p>The <code>Actor</code> to be removed.</p> required <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the actor is not on this cell.</p> Source code in <code>abses/cells.py</code> <pre><code>def remove(self, agent: Actor) -&gt; None:\n    \"\"\"Removes an Actor here.\n\n    Parameters:\n        agent:\n            The `Actor` to be removed.\n\n    Raises:\n        ABSESpyError:\n            If the actor is not on this cell.\n    \"\"\"\n    try:\n        self._agents[agent.breed].remove(agent)\n    except KeyError as err:\n        raise ABSESpyError(f\"{agent} is not located at {self}.\") from err\n    agent.put_on()\n    if not self._agents[agent.breed]:\n        del self._agents[agent.breed]\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.linked","title":"linked","text":"<pre><code>linked(link)\n</code></pre> <p>Gets the body of the link to this patch.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>The link type to search.</p> required <p>Returns:</p> Type Description <code>ActorsList[Actor]</code> <p>An <code>ActorList</code> of <code>Actor</code> who has association with the patch.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>The input link should be a string of link name.</p> <code>KeyError</code> <p>The searched link is not available in the model.</p> Source code in <code>abses/cells.py</code> <pre><code>def linked(self, link: str) -&gt; ActorsList[Actor]:\n    \"\"\"Gets the body of the link to this patch.\n\n    Parameters:\n        link:\n            The link type to search.\n\n    Returns:\n        An `ActorList` of `Actor` who has association with the patch.\n\n    Raises:\n        TypeError:\n            The input link should be a string of link name.\n        KeyError:\n            The searched link is not available in the model.\n    \"\"\"\n    if link is None:\n        return self.agents\n    elif not isinstance(link, str):\n        raise TypeError(f\"{type(link)} is not valid link name.\")\n    elif link not in self.links:\n        raise KeyError(f\"{link} not exists in {self}.\")\n    else:\n        agents = ActorsList(self.model, super().linked(link=link))\n    return agents\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.linked_attr","title":"linked_attr","text":"<pre><code>linked_attr(attr, link=None, nodata=None, how='only')\n</code></pre> <p>Gets the properties of the agent linked to the patch.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The attribute name to retrieve.</p> required <code>link</code> <code>Optional[str]</code> <p>The link name to search associations.</p> <code>None</code> <code>nodata</code> <code>Any</code> <p>For the agents who don't have such an attribute, return a nodata as a placeholder.</p> <code>None</code> <code>how</code> <code>str</code> <p>Search mode. #TODO</p> <code>'only'</code> <p>Returns:</p> Type Description <code>Any</code> <p>Any type of retrieved data.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>The searched link is not available in the model.</p> Source code in <code>abses/cells.py</code> <pre><code>def linked_attr(\n    self,\n    attr: str,\n    link: Optional[str] = None,\n    nodata: Any = None,\n    how: str = \"only\",\n) -&gt; Any:\n    \"\"\"Gets the properties of the agent linked to the patch.\n\n    Parameters:\n        attr:\n            The attribute name to retrieve.\n        link:\n            The link name to search associations.\n        nodata:\n            For the agents who don't have such an attribute, return a nodata as a placeholder.\n        how:\n            Search mode. #TODO\n\n    Returns:\n        Any type of retrieved data.\n\n    Raises:\n        KeyError:\n            The searched link is not available in the model.\n    \"\"\"\n    try:\n        agents = self.linked(link=link)\n    except KeyError:\n        agents = ActorsList(self.model, [])\n    if nodata is None or agents:\n        return agg_agents_attr(agents=agents, attr=attr, how=how)\n    return nodata\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.get_neighboring_cells","title":"get_neighboring_cells","text":"<pre><code>get_neighboring_cells(moore=False, radius=1, include_center=False, annular=False)\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.get_neighboring_cells--todo-get-the-grid-around-the-patch","title":"TODO Get the grid around the patch.","text":"Source code in <code>abses/cells.py</code> <pre><code>def get_neighboring_cells(\n    self,\n    moore: bool = False,\n    radius: int = 1,\n    include_center: bool = False,\n    annular: bool = False,\n) -&gt; ActorsList:\n    \"\"\"#TODO Get the grid around the patch.\"\"\"\n    cells = self.layer.get_neighboring_cells(\n        self.pos, moore=moore, radius=radius, include_center=include_center\n    )\n    if annular:\n        interiors = self.layer.get_neighboring_cells(\n            self.pos, moore=moore, radius=radius - 1, include_center=False\n        )\n        return ActorsList(self.model, set(cells) - set(interiors))\n    return ActorsList(self.model, cells)\n</code></pre>"},{"location":"api/container/","title":"Actors Container","text":""},{"location":"api/container/#actors-container","title":"Actors' Container","text":"<p>             Bases: <code>dict</code></p> <p>Singleton AgentsContainer for each model.</p> <p>This class is a dictionary-like container for managing agents in a simulation model. It is designed to be a singleton, meaning that there is only one instance of this class per model. It provides methods for creating, adding, removing, and selecting agents, as well as triggering events.</p> Source code in <code>abses/container.py</code> <pre><code>def __init__(self, model: MainModel):\n    super().__init__()\n    self._model = model\n    self._breeds = {}\n</code></pre>"},{"location":"api/container/#abses.container.AgentsContainer.breeds","title":"breeds  <code>property</code>","text":"<pre><code>breeds\n</code></pre> <p>Get all breeds in the model</p>"},{"location":"api/container/#abses.container.AgentsContainer.model","title":"model  <code>property</code>","text":"<pre><code>model\n</code></pre> <p>The ABSESpy model where the container belongs to.</p>"},{"location":"api/container/#abses.container.AgentsContainer.register_a_breed","title":"register_a_breed","text":"<pre><code>register_a_breed(actor_cls)\n</code></pre> <p>Register a new breed of actors in the container.</p> <p>Parameters:</p> Name Type Description Default <code>actor_cls</code> <code>type[Actor]</code> <p>The class of the actor to be registered.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the given class is not a subclass of <code>Actor</code>.</p> Source code in <code>abses/container.py</code> <pre><code>def register_a_breed(self, actor_cls: type[Actor]) -&gt; None:\n    \"\"\"Register a new breed of actors in the container.\n\n    Parameters:\n        actor_cls:\n            The class of the actor to be registered.\n\n    Raises:\n        TypeError:\n            If the given class is not a subclass of `Actor`.\n    \"\"\"\n    if not issubclass(actor_cls, Actor):\n        raise TypeError(f\"'{actor_cls}' not subclass of 'Actor'.\")\n    self._breeds[actor_cls.breed] = actor_cls\n    self[actor_cls.breed] = set()\n</code></pre>"},{"location":"api/container/#abses.container.AgentsContainer.create","title":"create","text":"<pre><code>create(breed_cls, num=1, singleton=False, **kwargs)\n</code></pre> <p>Create one or more actors of the given breed class.</p> <p>Parameters:</p> Name Type Description Default <code>breed_cls</code> <code>Type[Actor]</code> <p>The breed class of the actor(s) to create.</p> required <code>num</code> <code>int</code> <p>The number of actors to create. Defaults to 1.</p> <code>1</code> <code>singleton</code> <code>bool</code> <p>Whether to create a singleton actor. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the actor constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Actor, ActorsList[Actor]]</code> <p>The created actor(s).</p> Example <pre><code>from abses import Actor, MainModel\nmodel = MainModel()\nactor = model.agents.create(singleton=True)\n&gt;&gt;&gt; type(actor)\n&gt;&gt;&gt; Actor\n\nactors = model.agents.create(singleton=False)\n&gt;&gt;&gt; type(actors)\n&gt;&gt;&gt; ActorsList\n</code></pre> Source code in <code>abses/container.py</code> <pre><code>def create(\n    self,\n    breed_cls: Type[Actor],\n    num: int = 1,\n    singleton: bool = False,\n    **kwargs,\n) -&gt; Union[Actor, ActorsList[Actor]]:\n    \"\"\"Create one or more actors of the given breed class.\n\n    Parameters:\n        breed_cls:\n            The breed class of the actor(s) to create.\n        num:\n            The number of actors to create. Defaults to 1.\n        singleton (bool, optional):\n            Whether to create a singleton actor. Defaults to False.\n        **kwargs:\n            Additional keyword arguments to pass to the actor constructor.\n\n    Returns:\n        The created actor(s).\n\n    Example:\n        ```python\n        from abses import Actor, MainModel\n        model = MainModel()\n        actor = model.agents.create(singleton=True)\n        &gt;&gt;&gt; type(actor)\n        &gt;&gt;&gt; Actor\n\n        actors = model.agents.create(singleton=False)\n        &gt;&gt;&gt; type(actors)\n        &gt;&gt;&gt; ActorsList\n        ```\n    \"\"\"\n    objs = [breed_cls(self._model, **kwargs) for _ in range(num)]\n    agents = ActorsList(self._model, objs)\n    self.add(agents, register=True)\n    if singleton:\n        return agents[0] if num == 1 else agents\n    return agents\n</code></pre>"},{"location":"api/container/#abses.container.AgentsContainer.to_list","title":"to_list","text":"<pre><code>to_list(breeds=None)\n</code></pre> <p>Get all entities of specified breeds to a list.</p> <p>Parameters:</p> Name Type Description Default <code>breeds</code> <code>Optional[Union[str, Iterable[str]]]</code> <p>The breed(s) of entities to convert to a list (Optional[Union[str, Iterable[str]]]). If None, all breeds are used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ActorsList</code> <code>ActorsList[Actor]</code> <p>A list of entities of the specified breeds.</p> Source code in <code>abses/container.py</code> <pre><code>def to_list(\n    self, breeds: Optional[Union[str, Iterable[str]]] = None\n) -&gt; ActorsList[Actor]:\n    \"\"\"Get all entities of specified breeds to a list.\n\n    Parameters:\n        breeds:\n            The breed(s) of entities to convert to a list (Optional[Union[str, Iterable[str]]]). If None, all breeds are used.\n\n    Returns:\n        ActorsList:\n            A list of entities of the specified breeds.\n    \"\"\"\n    if breeds is None:\n        breeds = self.breeds\n    agents = ActorsList(self._model)\n    for breed in make_list(breeds):\n        agents.extend(self[breed])\n    return agents\n</code></pre>"},{"location":"api/container/#abses.container.AgentsContainer.trigger","title":"trigger","text":"<pre><code>trigger(*args, **kwargs)\n</code></pre> <p>Trigger a function for all agents in the container.</p> <p>This method calls the <code>trigger</code> method of the list of agents in the container, passing the same arguments and keyword arguments received by this method.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments to be passed to the <code>trigger</code> method of each agent.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to be passed to the <code>trigger</code> method of each agent.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p> Source code in <code>abses/container.py</code> <pre><code>def trigger(self, *args, **kwargs) -&gt; Any:\n    \"\"\"Trigger a function for all agents in the container.\n\n    This method calls the `trigger` method of the list of agents in the container,\n    passing the same arguments and keyword arguments received by this method.\n\n    Parameters:\n        *args:\n            Positional arguments to be passed to the `trigger` method of each agent.\n        **kwargs:\n            Keyword arguments to be passed to the `trigger` method of each agent.\n\n    Returns:\n        None\n    \"\"\"\n    return self.to_list().trigger(*args, **kwargs)\n</code></pre>"},{"location":"api/container/#abses.container.AgentsContainer.add","title":"add","text":"<pre><code>add(agents=None, register=False)\n</code></pre> <p>Add one or more actors to the container.</p> <p>Parameters:</p> Name Type Description Default <code>agents</code> <code>Union[Actor, ActorsList, Iterable[Actor]]</code> <p>The actor(s) to add to the container. Defaults to None.</p> <code>None</code> <code>register</code> <code>bool</code> <p>Whether to register the actor(s) if they belong to a new breed. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a breed of the actor(s) is not registered and <code>register</code> is False.</p> Source code in <code>abses/container.py</code> <pre><code>def add(\n    self,\n    agents: Union[Actor, ActorsList, Iterable[Actor]] = None,\n    register: bool = False,\n) -&gt; None:\n    \"\"\"Add one or more actors to the container.\n\n    Parameters:\n        agents:\n            The actor(s) to add to the container. Defaults to None.\n        register:\n            Whether to register the actor(s) if they belong to a new breed. Defaults to False.\n\n    Raises:\n        TypeError:\n            If a breed of the actor(s) is not registered and `register` is False.\n    \"\"\"\n    dic = ActorsList(self._model, make_list(agents)).to_dict()\n    for k, actors_lst in dic.items():\n        if k not in self.breeds:\n            if register:\n                self._register(actors_lst[0])\n            else:\n                raise TypeError(f\"'{k}' not registered.\")\n        self[k] = self[k].union(actors_lst)\n</code></pre>"},{"location":"api/container/#abses.container.AgentsContainer.remove","title":"remove","text":"<pre><code>remove(agent)\n</code></pre> <p>Remove the given agent from the container.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Actor</code> <p>The agent (actor) to remove.</p> required Source code in <code>abses/container.py</code> <pre><code>def remove(self, agent: Actor) -&gt; None:\n    \"\"\"Remove the given agent from the container.\n\n    Parameters:\n        agent:\n            The agent (actor) to remove.\n    \"\"\"\n    self[agent.breed].remove(agent)\n</code></pre>"},{"location":"api/container/#abses.container.AgentsContainer.select","title":"select","text":"<pre><code>select(selection)\n</code></pre> <p>Selects the actors that match the given selection criteria.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Selection</code> <p>The selection criteria to apply.</p> required <p>Returns:</p> Type Description <code>ActorsList</code> <p>A list of actors that match the selection criteria.</p> Source code in <code>abses/container.py</code> <pre><code>def select(self, selection: Selection) -&gt; ActorsList:\n    \"\"\"Selects the actors that match the given selection criteria.\n\n    Parameters:\n        selection:\n            The selection criteria to apply.\n\n    Returns:\n        A list of actors that match the selection criteria.\n    \"\"\"\n    return self.to_list().select(selection)\n</code></pre>"},{"location":"api/decisions/","title":"Decision","text":"<p>Decision class of actor.</p> Source code in <code>abses/decision.py</code> <pre><code>def __init__(self, agent: Actor = None) -&gt; None:\n    self._agent: Actor = agent\n    self._strategy: Any = self._setup()\n</code></pre> <p>Creating and containing decisions of an agent.</p> Source code in <code>abses/decision.py</code> <pre><code>def __init__(\n    self, agent: Actor, decisions: Optional[Iterable[Decision]] = None\n) -&gt; None:\n    self.agent: Actor = agent\n    self._decisions: Dict[str, Decision] = {}\n    self.parse_decisions(decisions)\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.name","title":"name  <code>classmethod</code> <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Get the name of the decision. By default, this will be a snake name of class name. Users can custom it by assigning a class attribute <code>name_as</code>.</p> Example <pre><code>class TestDecision(Decision):\n    pass\n&gt;&gt;&gt; decision = TestDecision()\n&gt;&gt;&gt; decision.name\n&gt;&gt;&gt; 'test_decision'\n\nclass TestDecision(Decision):\n    name_as: str = 'decision'\n&gt;&gt;&gt; decision = TestDecision()\n&gt;&gt;&gt; decision.name\n&gt;&gt;&gt; 'decision'\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.strategies","title":"strategies  <code>classmethod</code> <code>property</code>","text":"<pre><code>strategies\n</code></pre> <p>Possible strategies.</p>"},{"location":"api/decisions/#abses.decision.Decision.agent","title":"agent  <code>property</code>","text":"<pre><code>agent\n</code></pre> <p>Decision-maker.</p>"},{"location":"api/decisions/#abses.decision.Decision.now","title":"now  <code>property</code>","text":"<pre><code>now\n</code></pre> <p>The strategy now.</p>"},{"location":"api/decisions/#abses.decision.Decision.validate_strategies","title":"validate_strategies  <code>classmethod</code>","text":"<pre><code>validate_strategies(strategies)\n</code></pre> <p>Check if the strategies valid.</p> Source code in <code>abses/decision.py</code> <pre><code>@classmethod\ndef validate_strategies(cls, strategies: Strategy):\n    \"\"\"Check if the strategies valid.\"\"\"\n    if not isinstance(strategies, Dict):\n        raise TypeError(\n            f\"So far, only discrete strategies are supported, you should set '__strategies__' class attribute with a dictionary of strategies when subclassing 'Decision', got {type(strategies)} instead.\"\n        )\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.set_strategies","title":"set_strategies  <code>classmethod</code>","text":"<pre><code>set_strategies(strategies)\n</code></pre> <p>Parsing strategies and save into properties.</p> Source code in <code>abses/decision.py</code> <pre><code>@classmethod\ndef set_strategies(cls, strategies: Strategy) -&gt; None:\n    \"\"\"Parsing strategies and save into properties.\"\"\"\n    cls._strategies = strategies\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.making","title":"making  <code>classmethod</code>","text":"<pre><code>making(method)\n</code></pre> <p>A decorator makes this decision.</p> Source code in <code>abses/decision.py</code> <pre><code>@classmethod\ndef making(cls, method: Callable) -&gt; Callable:\n    \"\"\"A decorator makes this decision.\"\"\"\n\n    @wraps(method)\n    def decorated(self: Actor, *args, **kwargs):\n        cls.validate_decision_maker(self)\n        result = method(self, *args, **kwargs)\n        cls.validate_strategy(result)\n        return result\n\n    decorated.__making__ = cls\n    return decorated\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.response","title":"response  <code>classmethod</code>","text":"<pre><code>response(strategy)\n</code></pre> <p>Change the decorated function into a response methods.</p> Source code in <code>abses/decision.py</code> <pre><code>@classmethod\ndef response(cls, strategy: Strategy) -&gt; Callable:\n    \"\"\"Change the decorated function into a response methods.\"\"\"\n\n    def decorator(func) -&gt; Callable:\n        @wraps(func)\n        def wrapper(self: Actor, *args, **kwargs):\n            if not hasattr(self, \"decisions\"):\n                raise AttributeError(\n                    f\"{self.breed} doesn't have an attribute 'decisions'\"\n                )\n            if not isinstance(getattr(self, \"decisions\"), DecisionFactory):\n                raise TypeError(\"Type of a decision must be decision.\")\n            decision_obj = self.decisions.get(cls.name)\n            if not decision_obj.has_strategy(strategy):\n                raise TypeError(\n                    f\"Decision '{cls.name}' doesn't have strategy {strategy}.\"\n                )\n            return func(self, *args, **kwargs)\n\n        wrapper.__response__ = cls\n        wrapper.__expected__ = strategy\n        return wrapper\n\n    # decorator.__response__ = cls\n    return decorator\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.validate_decision_maker","title":"validate_decision_maker  <code>classmethod</code>","text":"<pre><code>validate_decision_maker(agent)\n</code></pre> <p>Validate maker of this decision.</p> Source code in <code>abses/decision.py</code> <pre><code>@classmethod\ndef validate_decision_maker(cls, agent: Actor):\n    \"\"\"Validate maker of this decision.\"\"\"\n    from abses.actor import Actor\n\n    if not isinstance(agent, Actor):\n        raise TypeError(\n            f\"Decision maker should be an instance of 'Actor' class, got {type(agent)} instead.\"\n        )\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.validate_strategy","title":"validate_strategy  <code>classmethod</code>","text":"<pre><code>validate_strategy(strategy)\n</code></pre> <p>Validate a strategy choice.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>Strategy</code> <p>The strategy to validate.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the strategy is not a valid choice.</p> Source code in <code>abses/decision.py</code> <pre><code>@classmethod\ndef validate_strategy(cls, strategy: Strategy) -&gt; None:\n    \"\"\"Validate a strategy choice.\n\n    Parameters:\n        strategy:\n            The strategy to validate.\n\n    Raises:\n        KeyError:\n            If the strategy is not a valid choice.\n    \"\"\"\n    if not cls.has_strategy(strategy=strategy):\n        raise KeyError(\n            f\"Decision '{cls.__name__}' doesn't have a valid strategy {strategy}.\"\n        )\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.has_strategy","title":"has_strategy  <code>classmethod</code>","text":"<pre><code>has_strategy(strategy)\n</code></pre> <p>Is a specific strategy existing in this decision?</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>Strategy</code> <p>The strategy to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the strategy exists, return True, otherwise returns False.</p> Source code in <code>abses/decision.py</code> <pre><code>@classmethod\ndef has_strategy(cls, strategy: Strategy) -&gt; bool:\n    \"\"\"Is a specific strategy existing in this decision?\n\n    Parameters:\n        strategy:\n            The strategy to validate.\n\n    Returns:\n        If the strategy exists, return True, otherwise returns False.\n    \"\"\"\n    return strategy in cls.strategies.keys()\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.setup","title":"setup","text":"<pre><code>setup()\n</code></pre> <p>Overwrite to setup an initial strategy for this decision.</p> Source code in <code>abses/decision.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Overwrite to setup an initial strategy for this decision.\"\"\"\n</code></pre>"},{"location":"api/decisions/#abses.decision.Decision.make","title":"make","text":"<pre><code>make()\n</code></pre> <p>Overwrite this method to do something else after make decision.</p> Source code in <code>abses/decision.py</code> <pre><code>def make(self) -&gt; None:\n    \"\"\"Overwrite this method to do something else after make decision.\"\"\"\n</code></pre>"},{"location":"api/decisions/#abses.decision.DecisionFactory.agent","title":"agent  <code>property</code> <code>writable</code>","text":"<pre><code>agent\n</code></pre> <p>Decision-maker, who has these decisions.</p>"},{"location":"api/decisions/#abses.decision.DecisionFactory.parse_decisions","title":"parse_decisions","text":"<pre><code>parse_decisions(decisions)\n</code></pre> <p>Parse decisions and save into the container.</p> <p>Parameters:</p> Name Type Description Default <code>decisions</code> <code>Iterable[type(Decision)]</code> <p>Iterable <code>Decision</code> class.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input decision is not a subclass of <code>Decision</code>.</p> Source code in <code>abses/decision.py</code> <pre><code>def parse_decisions(self, decisions: Iterable[type(Decision)]):\n    \"\"\"Parse decisions and save into the container.\n\n    Parameters:\n        decisions:\n            Iterable `Decision` class.\n\n    Raises:\n        TypeError:\n            If the input decision is not a subclass of `Decision`.\n    \"\"\"\n    for d in decisions:\n        if not issubclass(d, Decision):\n            raise TypeError(\n                f\"Decision must be an subclass of 'Decision' class, got {type(d)} instead.\"\n            )\n        obj = d(agent=self.agent)\n        self._decisions[obj.name] = obj\n</code></pre>"},{"location":"api/decisions/#abses.decision.DecisionFactory.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Get all decision names.</p> Source code in <code>abses/decision.py</code> <pre><code>def keys(self) -&gt; List[str]:\n    \"\"\"Get all decision names.\"\"\"\n    return list(self._decisions.keys())\n</code></pre>"},{"location":"api/decisions/#abses.decision.DecisionFactory.get","title":"get","text":"<pre><code>get(name)\n</code></pre> <p>Get a decision by its name.</p> Source code in <code>abses/decision.py</code> <pre><code>def get(self, name: str) -&gt; Decision:\n    \"\"\"Get a decision by its name.\"\"\"\n    if name not in self._decisions:\n        raise KeyError(\n            f\"Decision '{name}' doesn't exist in {self.keys()}.\"\n        )\n    return self._decisions[name]\n</code></pre>"},{"location":"api/decisions/#abses.decision.DecisionFactory.making","title":"making","text":"<pre><code>making()\n</code></pre> <p>Making decisions.</p> Source code in <code>abses/decision.py</code> <pre><code>def making(self) -&gt; None:\n    \"\"\"Making decisions.\"\"\"\n    for d in self._decisions.values():\n        d._make()\n</code></pre>"},{"location":"api/human/","title":"human","text":""},{"location":"api/human/#major-human-module","title":"Major human module","text":"<p>             Bases: <code>CompositeModule</code>, <code>HumanModule</code>, <code>LinkContainer</code></p> <p>The Base Human Module.</p> Note <p>Look at this tutorial to understand the model structure.</p> Source code in <code>abses/human.py</code> <pre><code>def __init__(self, model, name=\"human\"):\n    LinkContainer.__init__(self)\n    HumanModule.__init__(self, model, name)\n    CompositeModule.__init__(self, model, name=name)\n</code></pre>"},{"location":"api/human/#human-submodule","title":"Human submodule","text":"<p>             Bases: <code>Module</code></p> <p>The <code>Human</code> sub-module base class.</p> Note <p>Look at this tutorial to understand the model structure.</p> <p>Attributes:</p> Name Type Description <code>agents</code> <code>AgentsContainer</code> <p>The agents container of this ABSESpy model.</p> <code>collections</code> <code>Set[str]</code> <p>Actor collections defined.</p> Source code in <code>abses/human.py</code> <pre><code>def __init__(self, model, name=None):\n    Module.__init__(self, model, name)\n    self._agents = AgentsContainer(model)\n    self._collections: Dict[str, Selection] = DictConfig({})\n</code></pre>"},{"location":"api/human/#abses.human.HumanModule.agents","title":"agents  <code>property</code>","text":"<pre><code>agents\n</code></pre> <p>The agents container of this ABSESpy model.</p>"},{"location":"api/human/#abses.human.HumanModule.collections","title":"collections  <code>property</code>","text":"<pre><code>collections\n</code></pre> <p>Actor collections defined.</p>"},{"location":"api/human/#abses.human.HumanModule.actors","title":"actors","text":"<pre><code>actors(name=None)\n</code></pre> <p>Different selections of agents</p> Source code in <code>abses/human.py</code> <pre><code>def actors(self, name: str | None = None) -&gt; ActorsList[Actor]:\n    \"\"\"Different selections of agents\"\"\"\n    if name is None:\n        return self.agents.to_list()\n    if name not in self._collections:\n        raise KeyError(f\"{name} is not defined.\")\n    selection = self._collections[name]\n    return self.actors().select(selection)\n</code></pre>"},{"location":"api/human/#abses.human.HumanModule.define","title":"define","text":"<pre><code>define(name, selection)\n</code></pre> <p>Define a query of actors and save it into collections.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>defined name of this group of actors.</p> required <code>selection</code> <code>Selection</code> <p>Selection query of <code>Actor</code>.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the name is already defined.</p> <p>Returns:</p> Type Description <code>ActorsList</code> <p>The list of actors who are satisfied the query condition.</p> Example <pre><code># Create 5 actors to query\nmodel=MainModel()\nmodel.agents.create(Actor, 5)\n\nmodule = HumanModule(model=model)\nactors = module.define(name='first', selection='ids=0')\n&gt;&gt;&gt; len(actors)\n&gt;&gt;&gt; 1\n\n&gt;&gt;&gt; module.actors('first') == actors\n&gt;&gt;&gt; True\n</code></pre> Source code in <code>abses/human.py</code> <pre><code>def define(self, name: str, selection: Selection) -&gt; ActorsList:\n    \"\"\"Define a query of actors and save it into collections.\n\n    Parameters:\n        name:\n            defined name of this group of actors.\n        selection:\n            Selection query of `Actor`.\n\n    Raises:\n        KeyError:\n            If the name is already defined.\n\n    Returns:\n        The list of actors who are satisfied the query condition.\n\n    Example:\n        ```\n        # Create 5 actors to query\n        model=MainModel()\n        model.agents.create(Actor, 5)\n\n        module = HumanModule(model=model)\n        actors = module.define(name='first', selection='ids=0')\n        &gt;&gt;&gt; len(actors)\n        &gt;&gt;&gt; 1\n\n        &gt;&gt;&gt; module.actors('first') == actors\n        &gt;&gt;&gt; True\n        ```\n    \"\"\"\n    if name in self._collections:\n        raise KeyError(f\"{name} is already defined.\")\n    selected = self.actors().select(selection)\n    self._collections[name] = selection\n    return selected\n</code></pre>"},{"location":"api/model/","title":"model","text":"<p>             Bases: <code>Generic[N]</code>, <code>Model</code>, <code>_Notice</code>, <code>States</code></p> <p>Base class of a main ABSESpy model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the model. By default, it's the lowercase of class name. E.g.: TestModel -&gt; testmodel.</p> <code>settings</code> <code>DictConfig</code> <p>Structured parameters of the model. Other module or submodules can search the configurations here structurally. For an example, if the settings is a nested DictConfig like {'nature': {'test': 3}}, users can access the parameter 'test = 3' by <code>model.nature.params.test</code>.</p> <code>human</code> <code>H</code> <p>The Human module.</p> <code>nature</code> <code>N</code> <p>The nature module.</p> <code>time</code> <code>TimeDriver</code> <p>Time driver.</p> <code>params</code> <code>DictConfig</code> <p>Parameters of the model.</p> <code>run_id</code> <code>int | None</code> <p>The run id of the current model. It's useful in batch run.</p> <code>agents</code> <code>AgentsContainer</code> <p>The container of all agents. One model only has one specific container where all alive agents are stored.</p> <code>actors</code> <code>ActorsList</code> <p>All agents as a list. A model can create multiple lists referring different actors.</p> Source code in <code>abses/main.py</code> <pre><code>def __init__(\n    self,\n    parameters: DictConfig = DictConfig({}),\n    human_class: Type[H] = BaseHuman,\n    nature_class: Type[N] = BaseNature,\n    run_id: Optional[int] = None,\n    **kwargs,\n) -&gt; None:\n    Model.__init__(self, **kwargs)\n    _Notice.__init__(self)\n    States.__init__(self)\n\n    self._settings = DictConfig(parameters)\n    self._version: str = __version__\n    self._human = human_class(self)\n    self._nature = nature_class(self)\n    self._agents = AgentsContainer(model=self)\n    self._time = TimeDriver(model=self)\n    self._run_id: int | None = run_id\n    self._trigger(\"initialize\", order=(\"nature\", \"human\"))\n    self._trigger(\"set_state\", code=1)  # initial state\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.run_id","title":"run_id  <code>property</code>","text":"<pre><code>run_id\n</code></pre> <p>The run id of the current model. It's useful in batch run.</p>"},{"location":"api/model/#abses.main.MainModel.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>name of the model. By default, it's the lowercase of class name. E.g.: TestModel -&gt; testmodel.</p>"},{"location":"api/model/#abses.main.MainModel.version","title":"version  <code>property</code>","text":"<pre><code>version\n</code></pre> <p>Report the current version of this model.</p>"},{"location":"api/model/#abses.main.MainModel.settings","title":"settings  <code>property</code>","text":"<pre><code>settings\n</code></pre> <p>Structured parameters of the model. Other module or submodules can search the configurations here structurally.</p> <p>For an example, if the settings is a nested DictConfig like {'nature': {'test': 3}}, users can access the parameter 'test = 3' by <code>model.nature.params.test</code>.</p>"},{"location":"api/model/#abses.main.MainModel.agents","title":"agents  <code>property</code>","text":"<pre><code>agents\n</code></pre> <p>The container of all agents. One model only has one specific container where all alive agents are stored.</p>"},{"location":"api/model/#abses.main.MainModel.actors","title":"actors  <code>property</code>","text":"<pre><code>actors\n</code></pre> <p>All agents as a list. A model can create multiple lists referring different actors.</p>"},{"location":"api/model/#abses.main.MainModel.human","title":"human  <code>property</code>","text":"<pre><code>human\n</code></pre> <p>The Human class</p>"},{"location":"api/model/#abses.main.MainModel.nature","title":"nature  <code>property</code>","text":"<pre><code>nature\n</code></pre> <p>The Nature module</p>"},{"location":"api/model/#abses.main.MainModel.time","title":"time  <code>property</code>","text":"<pre><code>time\n</code></pre> <p>The time driver &amp; controller</p>"},{"location":"api/model/#abses.main.MainModel.params","title":"params  <code>property</code>","text":"<pre><code>params\n</code></pre> <p>The global parameters of this model.</p>"},{"location":"api/model/#abses.main.MainModel.run_model","title":"run_model","text":"<pre><code>run_model()\n</code></pre> <p>Start running the model, until the end situation is triggered.</p> Source code in <code>abses/main.py</code> <pre><code>def run_model(self) -&gt; None:\n    \"\"\"Start running the model, until the end situation is triggered.\"\"\"\n    self._setup()\n    while self.running:\n        self.step()\n        self.time.go()\n        self.time.stdout()\n    self._end()\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.setup","title":"setup","text":"<pre><code>setup()\n</code></pre> <p>Users can custom what to do when the model is setup and going to start running.</p> Source code in <code>abses/main.py</code> <pre><code>def setup(self):\n    \"\"\"Users can custom what to do when the model is setup and going to start running.\"\"\"\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>A step of the model.</p> Source code in <code>abses/main.py</code> <pre><code>def step(self):\n    \"\"\"A step of the model.\"\"\"\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.end","title":"end","text":"<pre><code>end()\n</code></pre> <p>Users can custom what to do when the model is end.</p> Source code in <code>abses/main.py</code> <pre><code>def end(self):\n    \"\"\"Users can custom what to do when the model is end.\"\"\"\n</code></pre>"},{"location":"api/nature/","title":"nature","text":""},{"location":"api/nature/#major-natural-module","title":"Major natural module","text":"<p>             Bases: <code>GeoSpace</code>, <code>CompositeModule</code></p> <p>The Base Nature Module. Note:     Look at this tutorial to understand the model structure.     This is NOT a raster layer, but can be seen as a container of different raster layers.     Users can create new raster layer (i.e., <code>PatchModule</code>) by <code>create_module</code> method.     By default, an initialized ABSESpy model will init an instance of this <code>BaseNature</code> as <code>nature</code> module.</p> <p>Attributes:</p> Name Type Description <code>major_layer</code> <code>PatchModule | None</code> <p>The major layer of nature module. By default, it's the first layer that user created.</p> <code>total_bounds</code> <code>ndarray | None</code> <p>The spatial scope of the model's concern. By default, uses the major layer of this model.</p> Source code in <code>abses/nature.py</code> <pre><code>def __init__(self, model, name=\"nature\"):\n    CompositeModule.__init__(self, model, name=name)\n    crs = self.params.get(\"crs\", CRS)\n    mg.GeoSpace.__init__(self, crs=crs)\n    self._major_layer = None\n</code></pre>"},{"location":"api/nature/#abses.nature.BaseNature.major_layer","title":"major_layer  <code>property</code> <code>writable</code>","text":"<pre><code>major_layer\n</code></pre> <p>The major layer of nature module. By default, it's the first layer that user created.</p>"},{"location":"api/nature/#abses.nature.BaseNature.total_bounds","title":"total_bounds  <code>property</code>","text":"<pre><code>total_bounds\n</code></pre> <p>Total bounds. The spatial scope of the model's concern. If None (by default), uses the major layer of this model. Usually, the major layer is the first layer sub-module you created.</p>"},{"location":"api/nature/#abses.nature.BaseNature.create_agents_from_gdf","title":"create_agents_from_gdf","text":"<pre><code>create_agents_from_gdf(gdf, unique_id='Index', agent_cls=Actor)\n</code></pre> <p>Create actors from a <code>geopandas.GeoDataFrame</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The <code>geopandas.GeoDataFrame</code> object to convert.</p> required <code>unique_id</code> <code>str</code> <p>A column name, denotes which column will be converted to unique index of created geo-agents (Social-ecological system Actors).</p> <code>'Index'</code> <code>agent_cls</code> <code>type[Actor]</code> <p>Agent class to create.</p> <code>Actor</code> <p>Returns:</p> Type Description <code>ActorsList[Actor]</code> <p>An <code>ActorsList</code> with all new created actors stored.</p> Source code in <code>abses/nature.py</code> <pre><code>def create_agents_from_gdf(\n    self,\n    gdf: geopandas.GeoDataFrame,\n    unique_id: str = \"Index\",\n    agent_cls: type[Actor] = Actor,\n) -&gt; ActorsList[Actor]:\n    \"\"\"Create actors from a `geopandas.GeoDataFrame` object.\n\n    Parameters:\n        gdf:\n            The `geopandas.GeoDataFrame` object to convert.\n        unique_id:\n            A column name, denotes which column will be converted to unique index of created geo-agents (Social-ecological system Actors).\n        agent_cls:\n            Agent class to create.\n\n    Returns:\n        An `ActorsList` with all new created actors stored.\n    \"\"\"\n    creator = mg.AgentCreator(\n        model=self.model, agent_class=agent_cls, crs=self.crs\n    )\n    agents = creator.from_GeoDataFrame(gdf=gdf, unique_id=unique_id)\n    self.model.agents.register_a_breed(agent_cls)\n    self.model.agents.add(agents)\n    return ActorsList(model=self.model, objs=agents)\n</code></pre>"},{"location":"api/nature/#abses.nature.BaseNature.create_module","title":"create_module","text":"<pre><code>create_module(module_class=PatchModule, how=None, **kwargs)\n</code></pre> <p>Creates a submodule of the raster layer.</p> <p>Parameters:</p> Name Type Description Default <code>module_class</code> <code>Module</code> <p>The custom module class.</p> <code>PatchModule</code> <code>how</code> <code>str | None</code> <p>Class method to call when creating the new sub-module (raster layer). So far, there are three options:     <code>from_resolution</code>: by selecting shape and resolution.     <code>from_file</code>: by input of a geo-tiff dataset.     <code>copy_layer</code>: by copying shape, resolution, bounds, crs, and coordinates of an existing submodule. if None (by default), just simply create a sub-module without any custom methods (i.e., use the base class <code>PatchModule</code>).</p> <code>None</code> <code>**kwargs</code> <p>Any other arg passed to the creation method. See corresponding method of your how option from <code>PatchModule</code> class methods.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PatchModule</code> <p>the created new module.</p> Source code in <code>abses/nature.py</code> <pre><code>def create_module(\n    self,\n    module_class: Module = PatchModule,\n    how: str | None = None,\n    **kwargs,\n) -&gt; PatchModule:\n    \"\"\"Creates a submodule of the raster layer.\n\n    Parameters:\n        module_class:\n            The custom module class.\n        how:\n            Class method to call when creating the new sub-module (raster layer). So far, there are three options:\n                `from_resolution`: by selecting shape and resolution.\n                `from_file`: by input of a geo-tiff dataset.\n                `copy_layer`: by copying shape, resolution, bounds, crs, and coordinates of an existing submodule.\n            if None (by default), just simply create a sub-module without any custom methods (i.e., use the base class `PatchModule`).\n        **kwargs:\n            Any other arg passed to the creation method. See corresponding method of your how option from `PatchModule` class methods.\n\n    Returns:\n        the created new module.\n    \"\"\"\n    module = super().create_module(module_class, how, **kwargs)\n    # \u5982\u679c\u662f\u7b2c\u4e00\u4e2a\u521b\u5efa\u7684\u6a21\u5757,\u5219\u5c06\u5176\u4f5c\u4e3a\u4e3b\u8981\u7684\u56fe\u5c42\n    if not self.layers:\n        self.major_layer = module\n    self.add_layer(module)\n    return module\n</code></pre>"},{"location":"api/nature/#natural-submodule","title":"Natural submodule","text":"<p>             Bases: <code>Module</code>, <code>RasterLayer</code></p> <p>The spatial sub-module base class. Inherit from this class to create a submodule. Look at this tutorial to understand the model structure. This is also a raster layer, inherited from the 'mesa-geo.RasterLayer' class, and can place agents.</p> <p>Attributes:</p> Name Type Description <code>cell_properties</code> <code>set[str]</code> <p>The accessible attributes of cells stored in this layer. All <code>PatchCell</code> methods which are decorated by the decorator <code>raster_attribute</code> should be appeared here.</p> <code>attributes</code> <code>set[str]</code> <p>All accessible attributes from this layer.</p> <code>file</code> <code>str | None</code> <p>If the module is created by reading a raster dataset, save the file path.</p> <code>shape2d</code> <code>Coordinate</code> <p>Raster shape in 2D (heigh, width).</p> <code>shape3d</code> <code>Coordinate</code> <p>Raster shape in 3D (1, heigh, width).</p> Source code in <code>abses/nature.py</code> <pre><code>def __init__(self, model, name=None, **kwargs):\n    Module.__init__(self, model, name=name)\n    mg.RasterLayer.__init__(self, **kwargs)\n    for cell in self.array_cells.flatten():\n        cell.layer = self\n    self._file = None\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.cell_properties","title":"cell_properties  <code>property</code>","text":"<pre><code>cell_properties\n</code></pre> <p>The accessible attributes of cells stored in this layer. All <code>PatchCell</code> methods which are decorated by the decorator <code>raster_attribute</code> should be appeared here.</p>"},{"location":"api/nature/#abses.nature.PatchModule.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes\n</code></pre> <p>All accessible attributes from this layer.</p>"},{"location":"api/nature/#abses.nature.PatchModule.file","title":"file  <code>property</code>","text":"<pre><code>file\n</code></pre> <p>If the module is created by reading a raster dataset, save the file path.</p>"},{"location":"api/nature/#abses.nature.PatchModule.shape2d","title":"shape2d  <code>property</code>","text":"<pre><code>shape2d\n</code></pre> <p>Raster shape in 2D (height, width). This is useful when working with 2d <code>numpy.array</code>.</p>"},{"location":"api/nature/#abses.nature.PatchModule.shape3d","title":"shape3d  <code>property</code>","text":"<pre><code>shape3d\n</code></pre> <p>Raster shape in 3D (1, heigh, width). This is useful when working with <code>rasterio</code> band.</p>"},{"location":"api/nature/#abses.nature.PatchModule.array_cells","title":"array_cells  <code>property</code>","text":"<pre><code>array_cells\n</code></pre> <p>Array type of the <code>PatchCell</code> stored in this module.</p>"},{"location":"api/nature/#abses.nature.PatchModule.coords","title":"coords  <code>property</code>","text":"<pre><code>coords\n</code></pre> <p>Coordinate system of the raster data. This is useful when working with <code>xarray.DataArray</code>.</p>"},{"location":"api/nature/#abses.nature.PatchModule.from_resolution","title":"from_resolution  <code>classmethod</code>","text":"<pre><code>from_resolution(model, name=None, shape=(10, 10), crs=CRS, resolution=1, cell_cls=PatchCell)\n</code></pre> <p>Create a layer from resolution.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MainModel</code> <p>ABSESpy Model that the new module belongs.</p> required <code>name</code> <code>str</code> <p>Name of the new module. If None (by default), using lowercase of the 'class.name'. E.g., class NewModule -&gt; newmodule.</p> <code>None</code> <code>shape</code> <code>Coordinate</code> <p>Array shape (height, width) of the new module. For example, if shape=(3, 5), it means the new module will store 15 cells.</p> <code>(10, 10)</code> <code>crs</code> <code>Optional[CRS | str]</code> <p>Coordinate Reference Systems. If passing a string object, should be able to parsed by <code>pyproj</code>. By default, we use CRS = \"epsg:4326\".</p> <code>CRS</code> <code>resolution</code> <code>Number</code> <p>Spatial Resolution when creating the coordinates. By default 1, it means shape (3, 5) will generate coordinates like {y: [0, 1, 2], x: [0, 1, 2, 3, 4]}. Similar, when using resolution=0.1, it will be {y: [.0, .1, .2], x: [.0, .1, .2, .3, .4]}.</p> <code>1</code> <code>cell_cls</code> <code>type[PatchCell]</code> <p>Class type of <code>PatchCell</code> to create.</p> <code>PatchCell</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of self (\"PatchModule\").</p> Source code in <code>abses/nature.py</code> <pre><code>@classmethod\ndef from_resolution(\n    cls,\n    model: MainModel,\n    name: str = None,\n    shape: Coordinate = (10, 10),\n    crs: Optional[pyproj.CRS | str] = CRS,\n    resolution: Number = 1,\n    cell_cls: type[PatchCell] = PatchCell,\n) -&gt; Self:\n    \"\"\"Create a layer from resolution.\n\n    Parameters:\n        model:\n            ABSESpy Model that the new module belongs.\n        name:\n            Name of the new module. If None (by default), using lowercase of the '__class__.__name__'. E.g., class NewModule -&gt; newmodule.\n        shape:\n            Array shape (height, width) of the new module. For example, if shape=(3, 5), it means the new module will store 15 cells.\n        crs:\n            Coordinate Reference Systems. If passing a string object, should be able to parsed by `pyproj`. By default, we use CRS = \"epsg:4326\".\n        resolution:\n            Spatial Resolution when creating the coordinates. By default 1, it means shape (3, 5) will generate coordinates like {y: [0, 1, 2], x: [0, 1, 2, 3, 4]}. Similar, when using resolution=0.1, it will be {y: [.0, .1, .2], x: [.0, .1, .2, .3, .4]}.\n        cell_cls:\n            Class type of `PatchCell` to create.\n\n    Returns:\n        A new instance of self (\"PatchModule\").\n    \"\"\"\n    height, width = shape\n    total_bounds = [0, 0, width * resolution, height * resolution]\n    return cls(\n        model,\n        name=name,\n        width=width,\n        height=height,\n        crs=crs,\n        total_bounds=total_bounds,\n        cell_cls=cell_cls,\n    )\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.copy_layer","title":"copy_layer  <code>classmethod</code>","text":"<pre><code>copy_layer(model, layer, name=None, cell_cls=PatchCell)\n</code></pre> <p>Copy an existing layer to create a new layer.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MainModel</code> <p>ABSESpy Model that the new module belongs.</p> required <code>layer</code> <code>Self</code> <p>Another layer to copy. These attributes will be copied: the coordinates, the crs, and the shape.</p> required <code>name</code> <code>Optional[str]</code> <p>Name of the new module. If None (by default), using lowercase of the 'class.name'. E.g., class NewModule -&gt; newmodule.</p> <code>None</code> <code>cell_cls</code> <code>PatchCell</code> <p>Class type of <code>PatchCell</code> to create.</p> <code>PatchCell</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of self (\"PatchModule\").</p> Source code in <code>abses/nature.py</code> <pre><code>@classmethod\ndef copy_layer(\n    cls,\n    model: MainModel,\n    layer: Self,\n    name: Optional[str] = None,\n    cell_cls: PatchCell = PatchCell,\n) -&gt; Self:\n    \"\"\"Copy an existing layer to create a new layer.\n\n    Parameters:\n        model:\n            ABSESpy Model that the new module belongs.\n        layer:\n            Another layer to copy. These attributes will be copied: the coordinates, the crs, and the shape.\n        name:\n            Name of the new module. If None (by default), using lowercase of the '__class__.__name__'. E.g., class NewModule -&gt; newmodule.\n        cell_cls:\n            Class type of `PatchCell` to create.\n\n    Returns:\n        A new instance of self (\"PatchModule\").\n    \"\"\"\n    if not isinstance(layer, PatchModule):\n        raise TypeError(f\"{layer} is not a valid PatchModule.\")\n\n    return cls(\n        model=model,\n        name=name,\n        width=layer.width,\n        height=layer.height,\n        crs=layer.crs,\n        total_bounds=layer.total_bounds,\n        cell_cls=cell_cls,\n    )\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(raster_file, cell_cls=PatchCell, attr_name=None, model=None, name=None)\n</code></pre> <p>Create a raster layer module from a file.</p> <p>Parameters:</p> Name Type Description Default <code>raster_file</code> <code>str</code> <p>File path of a geo-tiff dataset.</p> required <code>model</code> <code>None | MainModel</code> <p>ABSESpy Model that the new module belongs.</p> <code>None</code> <code>attr_name</code> <code>str | None</code> <p>Assign a attribute name to the loaded raster data.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Name of the new module. If None (by default), using lowercase of the 'class.name'. E.g., class NewModule -&gt; newmodule.</p> <code>None</code> <code>cell_cls</code> <code>type[Cell]</code> <p>Class type of <code>PatchCell</code> to create.</p> <code>PatchCell</code> Source code in <code>abses/nature.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    raster_file: str,\n    cell_cls: type[Cell] = PatchCell,\n    attr_name: str | None = None,\n    model: None | MainModel = None,\n    name: str | None = None,\n) -&gt; Self:\n    \"\"\"Create a raster layer module from a file.\n\n    Parameters:\n        raster_file:\n            File path of a geo-tiff dataset.\n        model:\n            ABSESpy Model that the new module belongs.\n        attr_name:\n            Assign a attribute name to the loaded raster data.\n        name:\n            Name of the new module. If None (by default), using lowercase of the '__class__.__name__'. E.g., class NewModule -&gt; newmodule.\n        cell_cls:\n            Class type of `PatchCell` to create.\n\n    \"\"\"\n    with rio.open(raster_file, \"r\") as dataset:\n        values = dataset.read()\n        _, height, width = values.shape\n        total_bounds = [\n            dataset.bounds.left,\n            dataset.bounds.bottom,\n            dataset.bounds.right,\n            dataset.bounds.top,\n        ]\n    obj = cls(\n        model=model,\n        name=name,\n        width=width,\n        height=height,\n        crs=dataset.crs,\n        total_bounds=total_bounds,\n        cell_cls=cell_cls,\n    )\n    obj._transform = dataset.transform\n    obj._file = raster_file\n    obj.apply_raster(values, attr_name=attr_name)\n    return obj\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.get_raster","title":"get_raster","text":"<pre><code>get_raster(attr_name=None)\n</code></pre> <p>Obtaining the Raster layer by attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str | None</code> <p>The attribute to retrieve. Update it if it is a dynamic variable. If None (by default), retrieve all attributes as a 3D array.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A 3D array of attribute.</p> Source code in <code>abses/nature.py</code> <pre><code>def get_raster(self, attr_name: str | None = None) -&gt; np.ndarray:\n    \"\"\"Obtaining the Raster layer by attribute.\n\n    Parameters:\n        attr_name:\n            The attribute to retrieve. Update it if it is a dynamic variable. If None (by default), retrieve all attributes as a 3D array.\n\n    Returns:\n        A 3D array of attribute.\n    \"\"\"\n    if attr_name not in self._dynamic_variables:\n        return super().get_raster(attr_name)\n    return self.dynamic_var(attr_name=attr_name).reshape(self.shape3d)\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.dynamic_var","title":"dynamic_var","text":"<pre><code>dynamic_var(attr_name)\n</code></pre> <p>Update and get dynamic variable.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The dynamic variable to retrieve.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>2D numpy.ndarray data of the variable.</p> Source code in <code>abses/nature.py</code> <pre><code>def dynamic_var(self, attr_name: str) -&gt; np.ndarray:\n    \"\"\"Update and get dynamic variable.\n\n    Parameters:\n        attr_name:\n            The dynamic variable to retrieve.\n\n    Returns:\n        2D numpy.ndarray data of the variable.\n    \"\"\"\n    array = super().dynamic_var(attr_name)\n    # \u5224\u65ad\u7b97\u51fa\u6765\u7684\u662f\u4e00\u4e2a\u7b26\u5408\u5f62\u72b6\u7684\u77e9\u9635\n    self._attr_or_array(array)\n    # \u5c06\u77e9\u9635\u8f6c\u6362\u4e3a\u4e09\u7ef4\uff0c\u5e76\u66f4\u65b0\u7a7a\u95f4\u6570\u636e\n    array_3d = array.reshape(self.shape3d)\n    self.apply_raster(array_3d, attr_name=attr_name)\n    return array\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.get_rasterio","title":"get_rasterio","text":"<pre><code>get_rasterio(attr_name=None)\n</code></pre> <p>Gets the Rasterio raster layer corresponding to the attribute. Save to a temporary rasterio memory file.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str | None</code> <p>The attribute name for creating the rasterio file.</p> <code>None</code> <p>Returns:</p> Type Description <code>MemoryFile</code> <p>The rasterio tmp memory file of raster.</p> Source code in <code>abses/nature.py</code> <pre><code>def get_rasterio(self, attr_name: str | None = None) -&gt; rio.MemoryFile:\n    \"\"\"Gets the Rasterio raster layer corresponding to the attribute. Save to a temporary rasterio memory file.\n\n    Parameters:\n        attr_name:\n            The attribute name for creating the rasterio file.\n\n    Returns:\n        The rasterio tmp memory file of raster.\n    \"\"\"\n    data = self.get_raster(attr_name=attr_name)\n    # \u5982\u679c\u83b7\u53d6\u5230\u7684\u662f2\u7ef4\uff0c\u91cd\u6574\u4e3a3\u7ef4\n    if len(data.shape):\n        data = data.reshape(self.shape3d)\n    with rio.MemoryFile() as mem_file:\n        with mem_file.open(\n            driver=\"GTiff\",\n            height=data.shape[1],\n            width=data.shape[2],\n            count=data.shape[0],  # number of bands\n            dtype=str(data.dtype),\n            crs=self.crs,\n            transform=self.transform,\n        ) as dataset:\n            dataset.write(data)\n        # Open the dataset again for reading and return\n        return mem_file.open()\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.geometric_cells","title":"geometric_cells","text":"<pre><code>geometric_cells(geometry, **kwargs)\n</code></pre> <p>Gets all the cells that intersect the given geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Geometry</code> <p>Shapely Geometry to search intersected cells.</p> required <code>**kwargs</code> <p>Args pass to the function <code>rasterio.mask.mask</code>. It influence how to build the mask for filtering cells. Please refer this doc for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[PatchCell]</code> <p>A list of PatchCell.</p> Source code in <code>abses/nature.py</code> <pre><code>def geometric_cells(self, geometry: Geometry, **kwargs) -&gt; List[PatchCell]:\n    \"\"\"Gets all the cells that intersect the given geometry.\n\n    Parameters:\n        geometry:\n            Shapely Geometry to search intersected cells.\n        **kwargs:\n            Args pass to the function `rasterio.mask.mask`. It influence how to build the mask for filtering cells. Please refer [this doc](https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html) for details.\n\n    Returns:\n        A list of PatchCell.\n    \"\"\"\n    data = self.get_rasterio(list(self.attributes)[0])\n    out_image, _ = mask.mask(data, [geometry], **kwargs)\n    mask_ = out_image.reshape(self.shape2d)\n    return list(self.array_cells[mask_.astype(bool)])\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.link_by_geometry","title":"link_by_geometry","text":"<pre><code>link_by_geometry(geo_agent, link=None, **kwargs)\n</code></pre> <p>Relates all cells intersecting a given geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geo_agent</code> <code>Actor</code> <p>An Actor who has geometry info.</p> required <code>link</code> <code>Optional[str]</code> <p>The link info to save.</p> <code>None</code> <code>**kwargs</code> <p>Args pass to the function <code>rasterio.mask.mask</code>. It influence how to build the mask for filtering cells. Please refer this doc for details.</p> <code>{}</code> Source code in <code>abses/nature.py</code> <pre><code>def link_by_geometry(\n    self, geo_agent: Actor, link: Optional[str] = None, **kwargs\n) -&gt; None:\n    \"\"\"Relates all cells intersecting a given geometry.\n\n    Parameters:\n        geo_agent:\n            An Actor who has geometry info.\n        link:\n            The link info to save.\n        **kwargs:\n            Args pass to the function `rasterio.mask.mask`. It influence how to build the mask for filtering cells. Please refer [this doc](https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html) for details.\n    \"\"\"\n    if not hasattr(geo_agent, \"geometry\"):\n        raise TypeError(f\"Agent {geo_agent} has no geometry.\")\n    cells = self.geometric_cells(geo_agent.geometry, **kwargs)\n    for cell in cells:\n        cell.link_to(agent=geo_agent, link=link)\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.batch_link_by_geometry","title":"batch_link_by_geometry","text":"<pre><code>batch_link_by_geometry(geo_agents, link=None, **kwargs)\n</code></pre> <p>The batch will assign intersecting grids to the main body based on geometry.</p> Source code in <code>abses/nature.py</code> <pre><code>def batch_link_by_geometry(\n    self, geo_agents: List[Actor], link: Optional[str] = None, **kwargs\n) -&gt; None:\n    \"\"\"The batch will assign intersecting grids to the main body based on geometry.\"\"\"\n    for geo_agent in geo_agents:\n        self.link_by_geometry(geo_agent, link, **kwargs)\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.linked_attr","title":"linked_attr","text":"<pre><code>linked_attr(attr_name, link=None, nodata=np.nan, how='only')\n</code></pre> <p>Gets the attribute linked to this layer.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The attribute name to search.</p> required <code>link</code> <code>Optional[str]</code> <p>The link name to get. If None (by default), get the actors located at each cell.</p> <code>None</code> <code>nodata</code> <code>Any</code> <p>On the cells without linked agent or located agent, return this nodata.</p> <code>nan</code> <code>how</code> <code>Optional[str]</code> <p>Search mode. Choose the behave when a cell is linked to or have more than one agent.     If 'only', raises ABSESpyError when more than one agent is found.     If 'random', random choose an agent from all searched agents.</p> <code>'only'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of searched attribute.</p> Source code in <code>abses/nature.py</code> <pre><code>def linked_attr(\n    self,\n    attr_name: str,\n    link: Optional[str] = None,\n    nodata: Any = np.nan,\n    how: Optional[str] = \"only\",\n) -&gt; np.ndarray:\n    \"\"\"Gets the attribute linked to this layer.\n\n    Parameters:\n        attr_name:\n            The attribute name to search.\n        link:\n            The link name to get. If None (by default), get the actors located at each cell.\n        nodata:\n            On the cells without linked agent or located agent, return this nodata.\n        how:\n            Search mode. Choose the behave when a cell is linked to or have more than one agent.\n                If 'only', raises ABSESpyError when more than one agent is found.\n                If 'random', random choose an agent from all searched agents.\n\n    Returns:\n        An array of searched attribute.\n    \"\"\"\n\n    def get_attr(cell: PatchCell, __name):\n        return cell.linked_attr(\n            attr=__name,\n            link=link,\n            nodata=nodata,\n            how=how,\n        )\n\n    return np.vectorize(get_attr)(self.array_cells, attr_name)\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.get_xarray","title":"get_xarray","text":"<pre><code>get_xarray(attr_name=None)\n</code></pre> <p>Get the xarray raster layer with spatial coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str | None</code> <p>The attribute to retrieve. If None (by default), return all available attributes (3D DataArray). Otherwise, 2D DataArray of the chosen attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Xarray.DataArray data with spatial coordinates of the chosen attribute.</p> Source code in <code>abses/nature.py</code> <pre><code>def get_xarray(self, attr_name: str | None = None) -&gt; xr.DataArray:\n    \"\"\"Get the xarray raster layer with spatial coordinates.\n\n    Parameters:\n        attr_name:\n            The attribute to retrieve. If None (by default), return all available attributes (3D DataArray). Otherwise, 2D DataArray of the chosen attribute.\n\n    Returns:\n        Xarray.DataArray data with spatial coordinates of the chosen attribute.\n    \"\"\"\n    data = self.get_raster(attr_name=attr_name)\n    if attr_name:\n        name = attr_name\n        data = data.reshape(self.shape2d)\n        coords = self.coords\n    else:\n        coords = {\"variable\": list(self.attributes)}\n        coords |= self.coords\n        name = self.name\n    return xr.DataArray(\n        data=data,\n        name=name,\n        coords=coords,\n    ).rio.write_crs(self.crs)\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.random_positions","title":"random_positions","text":"<pre><code>random_positions(k=1, where=None, prob=None, replace=False)\n</code></pre> <p>Choose 'k' <code>PatchCell</code> in the layer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>number of patches to choose.</p> <code>1</code> <code>mask</code> <p>bool mask, only True patches can be choose. If None, all patches are accessible. Defaults to None.</p> required <code>prob</code> <code>str | ndarray</code> <p>probability of each available position.</p> <code>None</code> <code>replace</code> <code>bool</code> <p>If a patch can be chosen more than once. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Coordinate]</code> <p>Iterable coordinates of chosen patches.</p> Source code in <code>abses/nature.py</code> <pre><code>def random_positions(\n    self,\n    k: int = 1,\n    where: str | np.ndarray = None,\n    prob: str | np.ndarray = None,\n    replace: bool = False,\n) -&gt; List[Coordinate]:\n    \"\"\"\n    Choose 'k' `PatchCell` in the layer randomly.\n\n    Parameters:\n        k:\n            number of patches to choose.\n        mask:\n            bool mask, only True patches can be choose. If None, all patches are accessible. Defaults to None.\n        prob:\n            probability of each available position.\n        replace:\n            If a patch can be chosen more than once. Defaults to False.\n\n    Returns:\n        Iterable coordinates of chosen patches.\n    \"\"\"\n    where = self._attr_or_array(where).flatten()\n    prob = self._attr_or_array(prob).flatten()\n    masked_prob = np.where(where, np.nan, prob)\n    return norm_choice(\n        self.array_cells.flatten(),\n        size=k,\n        p=masked_prob,\n        replace=replace,\n    )\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.has_agent","title":"has_agent","text":"<pre><code>has_agent(link=None, xarray=False)\n</code></pre> <p>If any actor is linked or existed in each cell.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>Optional[str]</code> <p>Link to search. If None (by default), search if any actor is located at in each cell.</p> <code>None</code> <code>xarray</code> <code>bool</code> <p>If True, return <code>Xarray.DataArray</code> object, <code>np.ndarray</code> otherwise (by default).</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A raster data shows weather any actor links or exists.</p> Source code in <code>abses/nature.py</code> <pre><code>def has_agent(\n    self, link: Optional[str] = None, xarray: bool = False\n) -&gt; np.ndarray:\n    \"\"\"If any actor is linked or existed in each cell.\n\n    Parameters:\n        link:\n            Link to search. If None (by default), search if any actor is located at in each cell.\n        xarray:\n            If True, return `Xarray.DataArray` object, `np.ndarray` otherwise (by default).\n\n    Returns:\n        A raster data shows weather any actor links or exists.\n    \"\"\"\n    if link is None:\n        data = np.vectorize(lambda x: x.has_agent)(self.array_cells)\n    else:\n        data = np.vectorize(lambda x: bool(x.linked(link)))(\n            self.array_cells\n        )\n    if xarray:\n        return xr.DataArray(\n            data=data,\n            coords=self.coords,\n            name=link or \"has_agent\",\n        ).rio.write_crs(self.crs)\n    return data\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.land_allotment","title":"land_allotment","text":"<pre><code>land_allotment(agent, link, where=None)\n</code></pre> <p>Allotment of land of this layer to actors.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Actor</code> <p>the actor to Affirmation of land link.</p> required <code>link</code> <code>str</code> <p>link name of the association.</p> required <code>where</code> <code>None | str | ndarray</code> <p>if None, all cells will be selected. if str, choose the corresponding attribute raster array as the mask. if ndarray, the input array should has the same 2d-shape with this layer.</p> <code>None</code> <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the shape of input array is not aligned with the shape of this layer.</p> Source code in <code>abses/nature.py</code> <pre><code>def land_allotment(\n    self, agent: Actor, link: str, where: None | str | np.ndarray = None\n) -&gt; None:\n    \"\"\"\n    Allotment of land of this layer to actors.\n\n    Parameters:\n        agent:\n            the actor to Affirmation of land link.\n        link:\n            link name of the association.\n        where:\n            if None, all cells will be selected.\n            if str, choose the corresponding attribute raster array as the mask.\n            if ndarray, the input array should has the same 2d-shape with this layer.\n\n    Raises:\n        ABSESpyError:\n            If the shape of input array is not aligned with the shape of this layer.\n    \"\"\"\n    mask_ = self._attr_or_array(where)\n    cells = self.array_cells[mask_]\n    for cell in cells:\n        cell.link_to(agent, link)\n</code></pre>"},{"location":"api/nature/#abses.nature.PatchModule.move_agent","title":"move_agent","text":"<pre><code>move_agent(agent, position)\n</code></pre> <p>Move an Actor to another position of this layer.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Actor</code> <p>The actor to operate.</p> required <code>position</code> <code>Coordinate</code> <p>The position to put on.</p> required <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the agent is not located at this layer before moving.</p> Source code in <code>abses/nature.py</code> <pre><code>def move_agent(self, agent: Actor, position: Coordinate) -&gt; None:\n    \"\"\"Move an Actor to another position of this layer.\n\n    Parameters:\n        agent:\n            The actor to operate.\n        position:\n            The position to put on.\n\n    Raises:\n        ABSESpyError:\n            If the agent is not located at this layer before moving.\n    \"\"\"\n    if agent.layer is not self:\n        raise ABSESpyError(f\"Agent {agent} is not on {self}.\")\n    agent.put_on_layer(self, position)\n</code></pre>"},{"location":"api/sequences/","title":"Actors Operation","text":"<p>             Bases: <code>list</code></p> <p>A list of actors in an agent-based model.</p> Source code in <code>abses/sequences.py</code> <pre><code>def __init__(self, model, objs=()):\n    super().__init__(objs)\n    self._model = model\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert all actors in this list to a dictionary like {breed: ActorList}.</p> <p>Returns:</p> Type Description <code>Dict[str, Self]</code> <p>key is the breed of actors, and values are corresponding actors.</p> Source code in <code>abses/sequences.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Self]:\n    \"\"\"Convert all actors in this list to a dictionary like {breed: ActorList}.\n\n    Returns:\n        key is the breed of actors, and values are corresponding actors.\n    \"\"\"\n    dic = {}\n    for actor in iter(self):\n        breed = actor.breed\n        if breed not in dic:\n            dic[breed] = ActorsList(self.model, [actor])\n        else:\n            dic[breed].append(actor)\n    return dic\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.select","title":"select","text":"<pre><code>select(selection)\n</code></pre> <p>Returns a new :class:<code>ActorList</code> based on <code>selection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Selection</code> <p>List with same length as the agent list. Positions that return True will be selected.</p> required Source code in <code>abses/sequences.py</code> <pre><code>def select(self, selection: Selection) -&gt; Self:\n    \"\"\"\n    Returns a new :class:`ActorList` based on `selection`.\n\n    Parameters:\n        selection:\n            List with same length as the agent list.\n            Positions that return True will be selected.\n    \"\"\"\n    if isinstance(selection, (str, dict)):\n        bool_ = [actor.selecting(selection) for actor in self]\n    elif isinstance(selection, (list, tuple, np.ndarray)):\n        bool_ = make_list(selection)\n    else:\n        raise TypeError(f\"Invalid selection type {type(selection)}\")\n    selected = [a for a, s in zip(self, bool_) if s]\n    return ActorsList(self.model, selected)\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.ids","title":"ids","text":"<pre><code>ids(ids)\n</code></pre> <p>Subsets ActorsList by a <code>ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Iterable[int]</code> <p>an iterable id list. List[id], ID is an attr of agent obj.</p> required <p>Returns:</p> Name Type Description <code>ActorList</code> <code>List[Actor]</code> <p>A subset of origin agents list.</p> Source code in <code>abses/sequences.py</code> <pre><code>def ids(self, ids: Iterable[int]) -&gt; List[Actor]:\n    \"\"\"Subsets ActorsList by a `ids`.\n\n    Parameters:\n        ids:\n            an iterable id list. List[id], ID is an attr of agent obj.\n\n    Returns:\n        ActorList: A subset of origin agents list.\n    \"\"\"\n    ids = make_list(ids)\n    return self.select([agent.id in ids for agent in self])\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.random_choose","title":"random_choose","text":"<pre><code>random_choose(size=1, prob=None, replace=True, as_list=False)\n</code></pre> <p>Randomly choose one or more actors from the current self object.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The number of actors to choose. Defaults to 1.</p> <code>1</code> <code>prob</code> <code>Optional[Iterable[float]]</code> <p>A list of probabilities for each actor to be chosen. If None, all actors have equal probability. Defaults to None.</p> <code>None</code> <code>replace</code> <code>bool</code> <p>Whether to sample with replacement. Defaults to True.</p> <code>True</code> <code>as_list</code> <code>bool</code> <p>Whether to return the result as a list of actors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Actor, Self]</code> <p>An Actor or an ActorList of multiple actors.</p> Notes <p>Given the parameter set size=1 and as_list=False, a single Actor object is returned. Given the parameter set size&gt;1 and as_list=False, a Self (ActorsList) object is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If size is not a positive integer.</p> Source code in <code>abses/sequences.py</code> <pre><code>def random_choose(\n    self,\n    size: int = 1,\n    prob: Optional[Iterable[float]] = None,\n    replace: bool = True,\n    as_list: bool = False,\n) -&gt; Union[Actor, Self]:\n    \"\"\"Randomly choose one or more actors from the current self object.\n\n    Parameters:\n        size:\n            The number of actors to choose. Defaults to 1.\n        prob:\n            A list of probabilities for each actor to be chosen.\n            If None, all actors have equal probability. Defaults to None.\n        replace:\n            Whether to sample with replacement. Defaults to True.\n        as_list:\n            Whether to return the result as a list of actors. Defaults to False.\n\n    Returns:\n        An Actor or an ActorList of multiple actors.\n\n    Notes:\n        Given the parameter set size=1 and as_list=False, a single Actor object is returned.\n        Given the parameter set size&gt;1 and as_list=False, a Self (ActorsList) object is returned.\n\n    Raises:\n        ValueError:\n            If size is not a positive integer.\n    \"\"\"\n    chosen = norm_choice(self, p=prob, size=size, replace=replace)\n    if as_list:\n        return ActorsList(self.model, objs=chosen)\n    if size == 1:\n        return chosen[0]\n    if size &gt; 1:\n        return ActorsList(self.model, chosen)\n    raise ValueError(f\"Invalid size {size}.\")\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.better","title":"better","text":"<pre><code>better(metric, than=None)\n</code></pre> <p>Selects the elements of the sequence that are better than a given value or actor based on a specified metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>The name of the attribute to use as the metric for comparison.</p> required <code>than</code> <code>Optional[Union[Number, Actor]]</code> <p>The value or actor to compare against. If None, selects the elements with the highest value for the specified metric. If a number, selects the elements with a value greater than the specified number. If an Actor, selects the elements with a value greater than the specified Actor's value for the specified metric.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new sequence containing the selected elements.</p> <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the <code>than</code> parameter is not a Number or an Actor.</p> Notes <p>This method compares the values of the specified metric for all elements in the sequence and selects the elements that are better than the specified value or actor. The comparison is based on the greater than operator (&gt;) for numbers and the difference between the values for actors.</p> Source code in <code>abses/sequences.py</code> <pre><code>def better(\n    self, metric: str, than: Optional[Union[Number, Actor]] = None\n) -&gt; Self:\n    \"\"\"\n    Selects the elements of the sequence that are better than a given value or actor\n    based on a specified metric.\n\n    Parameters:\n        metric:\n            The name of the attribute to use as the metric for comparison.\n        than:\n            The value or actor to compare against. If None, selects the elements with the\n            highest value for the specified metric. If a number, selects the elements with\n            a value greater than the specified number. If an Actor, selects the elements\n            with a value greater than the specified Actor's value for the specified metric.\n\n    Returns:\n        A new sequence containing the selected elements.\n\n    Raises:\n        ABSESpyError:\n            If the `than` parameter is not a Number or an Actor.\n\n    Notes:\n        This method compares the values of the specified metric for all elements in the\n        sequence and selects the elements that are better than the specified value or actor.\n        The comparison is based on the greater than operator (&gt;) for numbers and the\n        difference between the values for actors.\n    \"\"\"\n    metrics = self.array(attr=metric)\n    if than is None:\n        return self.select(metrics == max(metrics))\n    if isinstance(than, Number):\n        return self.select(metrics &gt; than)\n    if isinstance(than, mg.GeoAgent):\n        diff = self.array(metric) - getattr(than, metric)\n        return self.select(diff &gt; 0)\n    raise ABSESpyError(f\"Invalid than type {type(than)}.\")\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.update","title":"update","text":"<pre><code>update(attr, values)\n</code></pre> <p>Update the specified attribute of each agent in the sequence with the corresponding value in the given iterable.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute to update.</p> required <code>values</code> <code>Iterable[any]</code> <p>An iterable of values to update the attribute with. Must be the same length as the sequence.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of the values iterable does not match the length of the sequence.</p> Source code in <code>abses/sequences.py</code> <pre><code>def update(self, attr: str, values: Iterable[any]) -&gt; None:\n    \"\"\"Update the specified attribute of each agent in the sequence with the corresponding value in the given iterable.\n\n    Parameters:\n        attr:\n            The name of the attribute to update.\n        values:\n            An iterable of values to update the attribute with. Must be the same length as the sequence.\n\n    Raises:\n        ValueError:\n            If the length of the values iterable does not match the length of the sequence.\n    \"\"\"\n    self._is_same_length(values, rep_error=True)\n    for agent, val in zip(self, values):\n        setattr(agent, attr, val)\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.split","title":"split","text":"<pre><code>split(where)\n</code></pre> <p>Split agents into N+1 groups.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>Iterable[int]</code> <p>indexes [size=N] denotes where to split.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: N+1 groups: agents array</p> Source code in <code>abses/sequences.py</code> <pre><code>def split(self, where: Iterable[int]) -&gt; np.ndarray:\n    \"\"\"Split agents into N+1 groups.\n\n    Parameters:\n        where:\n            indexes [size=N] denotes where to split.\n\n    Returns:\n        np.ndarray: N+1 groups: agents array\n    \"\"\"\n    to_split = np.array(self)\n    return np.hsplit(to_split, where)\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.array","title":"array","text":"<pre><code>array(attr)\n</code></pre> <p>Convert the specified attribute of all actors to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute to convert to a numpy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the specified attribute of all actors.</p> Source code in <code>abses/sequences.py</code> <pre><code>def array(self, attr: str) -&gt; np.ndarray:\n    \"\"\"Convert the specified attribute of all actors to a numpy array.\n\n    Parameters:\n        attr:\n            The name of the attribute to convert to a numpy array.\n\n    Returns:\n        A numpy array containing the specified attribute of all actors.\n    \"\"\"\n    return np.array([getattr(actor, attr) for actor in self])\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.trigger","title":"trigger","text":"<pre><code>trigger(func_name, *args, **kwargs)\n</code></pre> <p>Call a method with the given name on all actors in the sequence.</p> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>str</code> <p>The name of the method to call on each actor.</p> required <code>*args</code> <p>Positional arguments to pass to the method.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to the method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of the results of calling the method on each actor.</p> Source code in <code>abses/sequences.py</code> <pre><code>def trigger(self, func_name: str, *args, **kwargs) -&gt; np.ndarray:\n    \"\"\"Call a method with the given name on all actors in the sequence.\n\n    Parameters:\n        func_name:\n            The name of the method to call on each actor.\n        *args:\n            Positional arguments to pass to the method.\n        **kwargs:\n            Keyword arguments to pass to the method.\n\n    Returns:\n        An array of the results of calling the method on each actor.\n    \"\"\"\n    results = [\n        getattr(actor, func_name)(*args, **kwargs) for actor in iter(self)\n    ]\n    return np.array(results)\n</code></pre>"},{"location":"api/time/","title":"Time Operation","text":"<p>A decorator to run a method based on a time condition.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>dict</code> <p>A dictionary containing conditions to check against the <code>time</code> attribute. The keys can be ['year', 'month', 'weekday', 'freqstr'].</p> required <code>when_run</code> <code>bool</code> <p>If True, the decorated method will run when the condition is met. If False, the decorated method will not run when the condition is met.</p> <code>True</code> Example <p><pre><code>class TestActor(Actor):\n    @time_condition(condition={\"month\": 1, \"day\": 1}, when_run=True)\n    def happy_new_year(self):\n        print(\"Today is 1th, January, Happy new year!\")\n\n\nparameters = {\"time\": {\"start\": \"1996-12-24\", \"days\": 1}}\n\n\nmodel = MainModel(parameters=parameters)\nagent = model.agents.create(TestActor, 1, singleton=True)\n\nfor _ in range(10):\n    print(f\"Time now is {model.time}\")\n    model.time.go()\n    agent.happy_new_year()\n</code></pre> It should be called again in the next year beginning (i.e., <code>1998-01-01</code>) if we run this model longer... It means, the function will be called when the condition is fully satisfied.</p> Source code in <code>abses/time.py</code> <pre><code>def time_condition(condition: dict, when_run: bool = True) -&gt; callable:\n    \"\"\"\n    A decorator to run a method based on a time condition.\n\n    Parameters:\n        condition:\n            A dictionary containing conditions to check against the `time` attribute.\n            The keys can be ['year', 'month', 'weekday', 'freqstr'].\n        when_run:\n            If True, the decorated method will run when the condition is met.\n            If False, the decorated method will not run when the condition is met.\n\n    Example:\n        ```\n        class TestActor(Actor):\n            @time_condition(condition={\"month\": 1, \"day\": 1}, when_run=True)\n            def happy_new_year(self):\n                print(\"Today is 1th, January, Happy new year!\")\n\n\n        parameters = {\"time\": {\"start\": \"1996-12-24\", \"days\": 1}}\n\n\n        model = MainModel(parameters=parameters)\n        agent = model.agents.create(TestActor, 1, singleton=True)\n\n        for _ in range(10):\n            print(f\"Time now is {model.time}\")\n            model.time.go()\n            agent.happy_new_year()\n        ```\n        It should be called again in the next year beginning (i.e., `1998-01-01`) if we run this model longer... It means, the function will be called when the condition is fully satisfied.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if not hasattr(self, \"time\"):\n                raise AttributeError(\n                    \"The object doesn't have a TimeDriver object as `time` attribute.\"\n                )\n            time = self.time\n            if not isinstance(time, TimeDriver):\n                raise TypeError(\"The `TimeDriver` must be existing.\")\n\n            satisfied = all(\n                getattr(time.dt, key, None) == value\n                for key, value in condition.items()\n            )\n\n            if (satisfied and when_run) or (not satisfied and not when_run):\n                return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre> <p>             Bases: <code>_Component</code></p> <p>TimeDriver provides the functionality to manage time.</p> <p>This class is responsible for managing the time of a simulation model. It keeps track of the current time period, updates it according to a given frequency, and provides properties to access different components of the current time period (e.g., day, hour, etc.). The <code>TimeDriver</code> class is a singleton, meaning that there can be only one instance of it per simulation model.</p> <p>When init a <code>TimeDriver</code>, it accepts below parameters:</p> Parameter Name Expected Data Type Default Value Description start str, None None If None: use the current time, else: should be a string which can be parsed by <code>pendulum.parse()</code>. end str, int, None None If it's a string that can be parsed into datetime the model should end until achieving this time; if int: the model should end in that tick; if None no auto-end. irregular bool False If False: not dive into an irregular mode (tick-mode); if True, the model will solve as an irregular mode. years int 0 Time duration in years for the duration mode. months int 0 Time duration in months for the duration mode. weeks int 0 Time duration in weeks for the duration mode. days int 0 Time duration in days for the duration mode. hours int 0 Time duration in hours for the duration mode. minutes int 0 Time duration in minutes for the duration mode. seconds int 0 Time duration in seconds for the duration mode. <p>See tutorial to see more.</p> Source code in <code>abses/time.py</code> <pre><code>def __init__(self, model: MainModel):\n    super().__init__(model=model, name=\"time\")\n    self._model: MainModel = model\n    self._tick: int = 0\n    self._start_dt: Optional[datetime] = None\n    self._duration: Optional[pendulum.duration] = None\n    self._history = deque()\n    self._parse_time_settings()\n</code></pre>"},{"location":"api/time/#abses.time.TimeDriver.should_end","title":"should_end  <code>property</code>","text":"<pre><code>should_end\n</code></pre> <p>Should the model end or not.</p>"},{"location":"api/time/#abses.time.TimeDriver.tick","title":"tick  <code>property</code>","text":"<pre><code>tick\n</code></pre> <p>Returns the current tick.</p>"},{"location":"api/time/#abses.time.TimeDriver.ticking_mode","title":"ticking_mode  <code>property</code>","text":"<pre><code>ticking_mode\n</code></pre> <p>Returns the ticking mode of the time driver.</p>"},{"location":"api/time/#abses.time.TimeDriver.history","title":"history  <code>property</code>","text":"<pre><code>history\n</code></pre> <p>Returns the history of the time driver.</p>"},{"location":"api/time/#abses.time.TimeDriver.duration","title":"duration  <code>property</code>","text":"<pre><code>duration\n</code></pre> <p>Returns the duration of the time driver.</p>"},{"location":"api/time/#abses.time.TimeDriver.start_dt","title":"start_dt  <code>property</code> <code>writable</code>","text":"<pre><code>start_dt\n</code></pre> <p>Returns the starting time for the model.</p>"},{"location":"api/time/#abses.time.TimeDriver.end_dt","title":"end_dt  <code>property</code> <code>writable</code>","text":"<pre><code>end_dt\n</code></pre> <p>The real-world time or the ticks when the model should be end.</p>"},{"location":"api/time/#abses.time.TimeDriver.dt","title":"dt  <code>property</code> <code>writable</code>","text":"<pre><code>dt\n</code></pre> <p>The current real-world time for the model without timezone information.</p>"},{"location":"api/time/#abses.time.TimeDriver.day","title":"day  <code>property</code>","text":"<pre><code>day\n</code></pre> <p>Returns the current day for the model.</p>"},{"location":"api/time/#abses.time.TimeDriver.dayofweek","title":"dayofweek  <code>property</code>","text":"<pre><code>dayofweek\n</code></pre> <p>Returns the number for the day of the week for the model.</p>"},{"location":"api/time/#abses.time.TimeDriver.dayofyear","title":"dayofyear  <code>property</code>","text":"<pre><code>dayofyear\n</code></pre> <p>Returns the day of the year for the model.</p>"},{"location":"api/time/#abses.time.TimeDriver.daysinmonth","title":"daysinmonth  <code>property</code>","text":"<pre><code>daysinmonth\n</code></pre> <p>Get the total number of days of the month that this period falls on for the model.</p>"},{"location":"api/time/#abses.time.TimeDriver.days_in_month","title":"days_in_month  <code>property</code>","text":"<pre><code>days_in_month\n</code></pre> <p>Get the total number of days in the month that this period falls on for the model.</p>"},{"location":"api/time/#abses.time.TimeDriver.hour","title":"hour  <code>property</code>","text":"<pre><code>hour\n</code></pre> <p>Get the hour of the day component of the Period.</p>"},{"location":"api/time/#abses.time.TimeDriver.minute","title":"minute  <code>property</code>","text":"<pre><code>minute\n</code></pre> <p>Get minute of the hour component of the Period.</p>"},{"location":"api/time/#abses.time.TimeDriver.month","title":"month  <code>property</code>","text":"<pre><code>month\n</code></pre> <p>Return the month the current model's Period falls on.</p>"},{"location":"api/time/#abses.time.TimeDriver.quarter","title":"quarter  <code>property</code>","text":"<pre><code>quarter\n</code></pre> <p>Return the quarter the current model's Period falls on.</p>"},{"location":"api/time/#abses.time.TimeDriver.qyear","title":"qyear  <code>property</code>","text":"<pre><code>qyear\n</code></pre> <p>Fiscal year a model's Period lies in according to its starting-quarter.</p>"},{"location":"api/time/#abses.time.TimeDriver.second","title":"second  <code>property</code>","text":"<pre><code>second\n</code></pre> <p>Get the second component of a model's Period.</p>"},{"location":"api/time/#abses.time.TimeDriver.ordinal","title":"ordinal  <code>property</code>","text":"<pre><code>ordinal\n</code></pre> <p>Returns period ordinal, which is the number of periods elapsed since a starting period.</p>"},{"location":"api/time/#abses.time.TimeDriver.is_leap_year","title":"is_leap_year  <code>property</code>","text":"<pre><code>is_leap_year\n</code></pre> <p>Return True if the period's year is in a leap year.</p>"},{"location":"api/time/#abses.time.TimeDriver.week","title":"week  <code>property</code>","text":"<pre><code>week\n</code></pre> <p>Get the week of the year on the given Period.</p>"},{"location":"api/time/#abses.time.TimeDriver.weekday","title":"weekday  <code>property</code>","text":"<pre><code>weekday\n</code></pre> <p>Day of the week the period lies in, with Monday=0 and Sunday=6.</p>"},{"location":"api/time/#abses.time.TimeDriver.weekofyear","title":"weekofyear  <code>property</code>","text":"<pre><code>weekofyear\n</code></pre> <p>Get the week of the year on the given Period.</p>"},{"location":"api/time/#abses.time.TimeDriver.year","title":"year  <code>property</code>","text":"<pre><code>year\n</code></pre> <p>Return the year this Period falls on.</p>"},{"location":"api/time/#abses.time.TimeDriver.day_of_year","title":"day_of_year  <code>property</code>","text":"<pre><code>day_of_year\n</code></pre> <p>Return the day of the year.</p>"},{"location":"api/time/#abses.time.TimeDriver.day_of_week","title":"day_of_week  <code>property</code>","text":"<pre><code>day_of_week\n</code></pre> <p>Day of the week the period lies in, with Monday=0 and Sunday=6.</p>"},{"location":"api/time/#abses.time.TimeDriver.go","title":"go","text":"<pre><code>go(ticks=1, **kwargs)\n</code></pre> <p>Increments the tick.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>int</code> <p>How many ticks to increase.</p> <code>1</code> Source code in <code>abses/time.py</code> <pre><code>def go(self, ticks: int = 1, **kwargs) -&gt; None:\n    \"\"\"Increments the tick.\n\n    Parameters:\n        ticks:\n            How many ticks to increase.\n    \"\"\"\n    if ticks &lt; 0:\n        raise ValueError(\"Ticks cannot be negative.\")\n    if ticks == 0 and self.ticking_mode != \"irregular\":\n        raise ValueError(\n            \"Ticks cannot be zero unless the ticking mode is 'irregular'.\"\n        )\n    if ticks &gt; 1:\n        for _ in range(ticks):\n            self.go(ticks=1, **kwargs)\n        return\n    # tick = 1\n    self._tick += ticks\n    if self.ticking_mode == \"duration\":\n        self.dt += self.duration\n        self._history.append(self.dt)\n    elif self.ticking_mode == \"irregular\":\n        self.dt += pendulum.duration(**kwargs)\n        self._history.append(self.dt)\n    elif self.ticking_mode != \"tick\":\n        raise ValueError(f\"Invalid ticking mode: {self.ticking_mode}\")\n    # end going\n    if self.should_end:\n        self._model.running = False\n</code></pre>"},{"location":"api/time/#abses.time.TimeDriver.stdout","title":"stdout","text":"<pre><code>stdout()\n</code></pre> <p>Print the current time.</p> Source code in <code>abses/time.py</code> <pre><code>def stdout(self) -&gt; None:\n    \"\"\"Print the current time.\"\"\"\n    report = f\"tick[{self.tick}] \" + self.strftime(\"%Y-%m-%d %H:%M:%S\")\n    # logger.info(report)\n    sys.stdout.write(\"\\r\" + report)\n    sys.stdout.flush()\n</code></pre>"},{"location":"api/time/#abses.time.TimeDriver.parse_duration","title":"parse_duration","text":"<pre><code>parse_duration(duration)\n</code></pre> <p>Set the duration of the time driver.</p> Source code in <code>abses/time.py</code> <pre><code>def parse_duration(self, duration: Dict[str, int]) -&gt; None:\n    \"\"\"Set the duration of the time driver.\"\"\"\n    valid_attributes = VALID_DT_ATTRS\n    valid_dict = {}\n    for attribute in valid_attributes:\n        value = duration.get(attribute, 0)\n        if not isinstance(value, int):\n            raise TypeError(f\"{attribute} must be an integer.\")\n        valid_dict[attribute] = value\n    if all(value == 0 for value in valid_dict.values()):\n        self._duration = None\n    else:\n        self._duration = pendulum.duration(**valid_dict)\n</code></pre>"},{"location":"api/time/#abses.time.TimeDriver.strftime","title":"strftime","text":"<pre><code>strftime(fmt)\n</code></pre> <p>Returns a string representing the current time.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>An explicit format string of datetime.</p> required Source code in <code>abses/time.py</code> <pre><code>def strftime(self, fmt: str) -&gt; str:\n    \"\"\"Returns a string representing the current time.\n\n    Parameters:\n        fmt:\n            An explicit format string of datetime.\n    \"\"\"\n    return self.dt.strftime(fmt)\n</code></pre>"},{"location":"api/variables/","title":"Dynamic Variables","text":"<p>Time dependent variable</p> <p>A time dependent function will take the model time driver as an input and return its value. The function can also take other variables as inputs. The function can be defined as a static method of a class or a function.</p> Source code in <code>abses/dynamic.py</code> <pre><code>def __init__(\n    self, name: str, obj: _BaseObj, data: Any, function: Callable\n) -&gt; None:\n    self._name: str = name\n    self._obj: _BaseObj = obj\n    self._data: Any = data\n    self._function: Callable = function\n</code></pre>"},{"location":"api/variables/#abses.dynamic._DynamicVariable.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Get the name of the variable</p>"},{"location":"api/variables/#abses.dynamic._DynamicVariable.name--returns","title":"Returns","text":"<p>name: str</p>"},{"location":"api/variables/#abses.dynamic._DynamicVariable.obj","title":"obj  <code>property</code> <code>writable</code>","text":"<pre><code>obj\n</code></pre> <p>Returns a base object instance</p> <p>Returns:</p> Name Type Description <code>obj</code> <p>_BaseObj</p>"},{"location":"api/variables/#abses.dynamic._DynamicVariable.data","title":"data  <code>property</code>","text":"<pre><code>data\n</code></pre> <p>Returns unused data</p> <p>Returns:</p> Name Type Description <code>data</code> <p>Any</p>"},{"location":"api/variables/#abses.dynamic._DynamicVariable.function","title":"function  <code>property</code>","text":"<pre><code>function\n</code></pre> <p>Get the function that calculates the variable</p> <p>Returns:</p> Name Type Description <code>function</code> <p>Callable</p>"},{"location":"api/variables/#abses.dynamic._DynamicVariable.time","title":"time  <code>property</code>","text":"<pre><code>time\n</code></pre> <p>Get the model time driver</p> <p>Returns:</p> Name Type Description <code>time</code> <p>abses.time._TimeDriver</p>"},{"location":"api/variables/#abses.dynamic._DynamicVariable.get_required_attributes","title":"get_required_attributes","text":"<pre><code>get_required_attributes(function)\n</code></pre> <p>Get the function required attributes</p> <p>Returns:</p> Name Type Description <code>required_attributes</code> <p>list[str]</p> Source code in <code>abses/dynamic.py</code> <pre><code>def get_required_attributes(self, function: Callable):\n    \"\"\"Get the function required attributes\n\n    Returns:\n        required_attributes:\n            list[str]\n    \"\"\"\n    # Get the source code of the function\n    source_code = inspect.getsource(function)\n    return [\n        attr\n        for attr in [\"data\", \"obj\", \"time\", \"name\"]\n        if attr in source_code\n    ]\n</code></pre>"},{"location":"api/variables/#abses.dynamic._DynamicVariable.now","title":"now","text":"<pre><code>now()\n</code></pre> <p>Return the dynamic variable function's output</p> <p>Returns:</p> Name Type Description <code>output</code> <code>Any</code> <p>Any</p> Source code in <code>abses/dynamic.py</code> <pre><code>def now(self) -&gt; Any:\n    \"\"\"Return the dynamic variable function's output\n\n    Returns:\n        output:\n            Any\n    \"\"\"\n    required_attrs = self.get_required_attributes(self.function)\n    args = {attr: getattr(self, attr) for attr in required_attrs}\n    return self.function(**args)\n</code></pre>"},{"location":"contribution/contribution/","title":"contribution","text":""},{"location":"contribution/contribution/#where-to-start","title":"Where to start?","text":"<ul> <li>Feel free to ask questions on the\u00a0mailing list.</li> <li>Ask usage questions (\"How to do?\") on\u00a0GitHub\u00a0Discussions.</li> <li>For less well-defined questions or ideas or to announce other projects of interest to users, use the\u00a0mailing list.</li> </ul>"},{"location":"contribution/suggestions/","title":"Feature suggestions and bug reports","text":""},{"location":"contribution/suggestions/#feature-suggestions-and-bug-reports","title":"Feature suggestions and bug reports","text":"<p>If you are brand new to\u00a0<code>ABSESpy</code>\u00a0or open-source development, we recommend going through the\u00a0GitHub\u00a0\u201cissues\u201d tab\u00a0to find issues that interest you. Once you\u2019ve found an exciting issue, you can return here to get your development environment set up.</p> <ul> <li>Report bugs, suggest features or view the source code\u00a0on\u00a0GitHub.</li> </ul>"},{"location":"drafts/Checking%20%60mypy%60%20strictly%20and%20static%20types./","title":"Checking `mypy` strictly and static types.","text":""},{"location":"drafts/Checking%20%60mypy%60%20strictly%20and%20static%20types./#refactoring","title":"Refactoring","text":"<ul> <li> #refactor\u267b\ufe0f Refer this blog to refine CI workflow</li> </ul>"},{"location":"drafts/Parallel%20operation%20%28maybe%20%60dask%60%29/","title":"Parallel operation (maybe `dask`)","text":""},{"location":"drafts/Parallel%20operation%20%28maybe%20%60dask%60%29/#performance-improvements","title":"Performance improvements","text":"<ul> <li> #zap\u26a1\ufe0f maybe use asyno</li> </ul>"},{"location":"drafts/better%20log%20control/","title":"Better log control","text":"<ul> <li> #docs\ud83d\udcc4 \u89e3\u51b3mkdocs-bibtex\u7248\u672c\u62a5\u9519\u95ee\u9898</li> <li> #docs\ud83d\udcc4 \u53c2\u8003\u8fd9\u4e2a\u6587\u6863\u6765\u90e8\u7f72</li> </ul> <p>\u8fd9\u91cc\u662f\u4e00\u4e2a\u6c49\u5316\u7684logrue\u6587\u6863</p> <ul> <li> #refactor\u267b\ufe0f The Start of the simulation can be a <code>Pendulum.datetime</code> instance. As the tick goes, we will have current and end times.</li> <li> #feat\u2728 Design patterns logger factory</li> </ul>"},{"location":"drafts/use%20%60dataclass%60%20or%20%60pydantic%60%20rather%20than%20dictionaries/","title":"Use `dataclass` or `pydantic` rather than dictionaries","text":""},{"location":"drafts/use%20%60dataclass%60%20or%20%60pydantic%60%20rather%20than%20dictionaries/#refactoring","title":"Refactoring","text":"<ul> <li> #refactor\u267b\ufe0f When store bottom data, use dataclass</li> </ul>"},{"location":"examples/gallery/","title":"Gallery","text":""},{"location":"examples/gallery/#gallery","title":"Gallery","text":"<p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p>"},{"location":"features/MoHuB/","title":"Unveiling Human Decision Dynamics in SES Modeling","text":""},{"location":"features/MoHuB/#human-behavior-modeling-framework","title":"Human behavior modeling framework","text":"<p>Simulating human behavior is paramount in the dynamic realm of Socio-Ecological Systems (SES) modeling. As critical actors, humans play a pivotal role in shaping the interactions and outcomes within SES. Recognizing the complexity and nuances of human actions, ABSESpy introduces an advanced framework to model intricate human behaviors effectively.</p> <p>The beauty of ABSESpy lies in its framework that seamlessly integrates these user-defined functions, creating a smooth workflow that mirrors the intricacies of human behavior in the real world. When implementing this human behavior framework with ABSESpy, users are allowed to define key elements of decision-making step by step with the following concepts:</p> <ul> <li>Decision: First, define the types of decisions that an actor can make. A particular type of decision can be made by various types of actors. However, pre-defining what the decision types are helps users to better understand and organize their models.</li> <li>Perception: Actors make decisions based on their perception of the surrounding world, including both the natural and social environments.</li> <li>Evaluate: As the process of evaluating perceptions can vary, different actors may have different methods of evaluating decisions. Users can choose different evaluation methods for the same decision across various actors.</li> <li>Response: Finally, based on the decision-making process, actors respond and their actions impact the surrounding environment.</li> </ul>"},{"location":"features/architectural_elegance/","title":"Architectural elegance","text":""},{"location":"features/architectural_elegance/#architectural-elegance-for-modular-socio-ecological-systems-modeling","title":"Architectural Elegance for Modular Socio-Ecological Systems Modeling","text":"<p>The beauty of <code>ABSESpy</code> lies in its architectural elegance, which offers modularity, flexibility, and user-driven customization. At the heart of <code>ABSESpy</code> is its Branch-Leaf structure, which organizes various modules to ensure clear differentiation and integration as needed.</p>"},{"location":"features/architectural_elegance/#the-branch-leaf-architecture","title":"The Branch-Leaf Architecture","text":"<p>The Main Model is the foundation of <code>ABSESpy</code>, which stores several parameters and global variables. Attached to this foundational model are two essential modules:</p> <ul> <li>Base Human: This module focuses on the human aspect, offering insights and simulations related to human behavior, decisions, and interactions.</li> <li>Base Nature: As the name suggests, this module is all about the natural environments, allowing for simulations and analyses of different ecological components.</li> </ul> <p>This structure is designed because of social-ecological systems' essential components, users can learn more about the background from this wiki page. Users can see this tutorial for organizing their model to use the architecture fully.</p>"},{"location":"features/architectural_elegance/#loosely-coupled-sub-modules","title":"Loosely coupled sub-modules","text":"<p>Under the umbrella of the basic modules, users can add more sub-modules, tailoring the system to suit complex modeling needs. This extensibility ensures that <code>ABSESpy</code> can evolve with your project's requirements.</p> <p>Every module in <code>ABSESpy</code> is loosely coupled. This design choice means users can write their implementations for different functional modules and seamlessly combine them within the overall SES model. A switch mechanism further enhances this feature, enabling users to turn on or off specific module functionalities as required quickly.</p>"},{"location":"features/architectural_elegance/#a-unique-container-of-agents","title":"A unique container of agents","text":"<p>In the social-ecological system (SES) context of <code>ABSESpy</code>, all entities are termed \"<code>Actors</code>.\" These actors are the observers of the model. They are stored in a specialized container, aptly named the Actors Container. This container is unique for a specific model so that all the related operations can easily be organized.</p>"},{"location":"features/architectural_elegance/#advantages-of-the-structure","title":"Advantages of the structure","text":"<p>The setups introduced above ensure that:</p> <ol> <li>Separation of Concerns: Natural modules, which might include multiple spatial data layers, are distinctly separated from human modules. The latter delves into the intricate logic of actor actions across social, economic, and other functional systems.</li> <li>Modular Testing: Users can run, test, and analyze different functional modules in isolation, ensuring precise and focused outcomes.</li> <li>Global to Individual Observations: While every actor can access global model information, they possess unique attributes, ensuring a blend of macro and micro perspectives.</li> <li>Structured Parameter Management: <code>ABSESpy</code> employs a well-structured parameter system to manage model parameters. For an in-depth understanding, please refer to the dedicated Parameter Management Documentation.</li> </ol> <p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p>"},{"location":"features/features/","title":"features","text":"<p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p> <p>Agent-based model (ABM) is essential for social-ecological systems (SES) research. <code>ABSESpy</code> is designed for modeling couples humans and nature systems by:</p> <ul> <li>Architectural Elegance for Modular Socio-Ecological Systems Modeling.</li> <li>Mastering Time in SES Modeling with Real-world Precision and Dynamic Updates.</li> <li>Unveiling Human Decision Dynamics in SES Modeling by an Advanced Human Behavior Simulating Framework.</li> </ul>"},{"location":"features/time_control/","title":"Control real-world time","text":"<p>In Socio-Ecological Systems (SES) modeling, a real-world event's natural or human-induced duration can range from seconds to centuries. Recognizing the importance of time in modeling real-world problems, ABSESpy introduces a superior time control mechanism that stands out from traditional agent-based modeling frameworks.</p>"},{"location":"features/time_control/#real-time-mode-simulating-the-actual-progression-of-time","title":"Real-time Mode: Simulating the Actual Progression of Time","text":"<p>Unlike traditional frameworks that rely solely on a simple time counter (often called 'tick'), <code>ABSESpy</code> brings forth the Real-time Mode as an extension of the conventional timing system of agent-based modeling frameworks. Through this feature, here are three modes that set <code>ABSESpy</code> apart:</p> <ul> <li>['tick' mode] Tick-tick Time Intervals: the same as traditional agent-based modeling framework and, by default, <code>ABSESpy</code> records each simulating step as an increment of counting ticker.</li> <li>['duration' mode] Customizable Time Intervals: Users can define any desired time interval for each simulation step. This interval can represent a minute, an hour, a day, or any other real-world period, allowing for a more authentic representation of SES dynamics.</li> <li>['irregular' mode] Variable Time Steps Per Tick: This mode empowers users to assign different time durations for each tick, granting unmatched flexibility. Whether a particular phase in your model needs to represent a day, and another a month, free-time mode has got you covered.</li> </ul>"},{"location":"features/time_control/#auto-update-dynamic-variables","title":"Auto-update Dynamic Variables","text":"<p>Of the most important reasons to use real-world data and time is dynamically loading and updating time-series datasets. Talk is cheap, please see this time control tutorial.</p> <p>Dynamic data may be beneficial because modeling the real-world SES problem often requires various datasets as inputs. You won't want to re-calculate the data in each step... So! Just define them as dynamic variables when initializing or setting up a module by uploading a <code>withdraw data function</code> and a <code>data source</code>. It should also be applied to spatial datasets! Like selecting a raster data through some withdrawing function like <code>xarray.DataArray.sel(time=...)</code>.</p>"},{"location":"features/time_control/#decorator-for-conditional-time-based-triggering","title":"Decorator for Conditional Time-based Triggering","text":"<p>To elevate the precision and applicability of time controls, <code>ABSESpy</code> introduces a dedicated decorator <code>time_condition</code>. This decorator can adorn any model component with custom methods. Even more impressive is that these methods only activate when specific time conditions are met. This ensures that certain actions or events only occur at the right moments in your simulation, mirroring real-world occurrences with higher fidelity.</p> <p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p>"},{"location":"home/acknowledge/","title":"acknowledge","text":""},{"location":"home/acknowledge/#sponsors","title":"Sponsors","text":"<ul> <li>This package has been supported by the National Natural Science Foundation of China (grant no. 42041007) and the National Natural Science Foundation of China Joint Fund for Scientific Research on Yellow River (grant no. U2243601).</li> </ul>"},{"location":"home/acknowledge/#thanks-to-all-contributors","title":"Thanks to all contributors","text":""},{"location":"home/audience/","title":"Audience","text":"<p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p>"},{"location":"home/dependencies/","title":"dependencies","text":""},{"location":"home/dependencies/#dependences","title":"Dependences","text":"<p><code>ABSESpy</code> framework is based on many excellent open-source projects:</p> Package Version Purpose python &gt;=3.9,&lt;4 Core programming language used for development prettytable ^3.6.0 To create and visualize tabular data easily pint ^0.20.1 For unit conversion and handling netcdf4 ^1.6.2 To read and write NetCDF and HDF5 files hydra-core ^1.3.2 For managing application configurations mesa-geo ^0.5.0 To create spatially explicit agent-based models xarray ^2023.8.0 To work with labelled multi-dimensional arrays fiona ^1.9.4.post1 For reading and writing vector data (shapefiles, etc)"},{"location":"home/install/","title":"install","text":""},{"location":"home/install/#install-the-package","title":"Install the package","text":"<p>Install with pip or your favorite PyPI package manager.</p> <pre><code>pip install abses\n</code></pre>"},{"location":"home/install/#check-out-tutorials","title":"Check out tutorials","text":"<p>We suggest to read our documentation in this order:</p> <ol> <li>Read this paper to get familiar with our main novelty.</li> <li>Know the basic structure for organizing your model.</li> <li>Get know how <code>ABSESpy</code> controls ticks and mock real-world time.</li> <li>Write your custom classes of Agent based on our advanced framework</li> </ol>"},{"location":"home/install/#check-api-references-when-building-your-model","title":"Check API references when building your model","text":"<ul> <li>Programming the nature module at first.</li> <li>In nature module, you may need custom <code>PatchCell</code></li> <li>Introducing your custom agents (actors in social-ecological system context) by referring this.</li> <li>Considering what decisions your agents need to make, apply our advanced decision-making framework. You may need to check the docs of <code>Decision</code>.</li> <li>Learn to create, manage, and operate your agents by referring <code>AgentsContainer</code> and <code>ActorsList</code>.</li> <li>Relate your model to real time by <code>TimeDriver</code>.</li> </ul>"},{"location":"home/license/","title":"license","text":""},{"location":"home/license/#license","title":"License","text":"<p>Copyright 2023, <code>ABSESpy</code> Shuang Song</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>https://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p><code>ABSESpy</code> bundles portions of <code>Mesa</code>, <code>mesa-geo</code>, <code>pandas</code>, <code>NumPy</code>, and <code>Xarray</code>; the full text of these licenses are included in the licenses directory.</p>"},{"location":"plugins/checks/","title":"Checks","text":"<p>@Author  : Shuang (Twist) Song @Contact   : SongshGeo@gmail.com GitHub   : https://github.com/SongshGeo Website: https://cv.songshgeo.com/</p> In\u00a0[\u00a0]: Copied! <pre>from mkdocs.config import Config\n</pre> from mkdocs.config import Config <p>\u8fd9\u4e2a\u5730\u65b9\u53ef\u4ee5\u52a0\u5165\u4e00\u4e9b\u81ea\u5b9a\u4e49\u7684\u5de5\u4f5c\u6d41\uff0c\u5728\u90e8\u7f72\u6587\u6863\u7684\u65f6\u5019\u8fd0\u884c\u3002 https://github.com/pydantic/pydantic/blob/main/docs/plugins/main.py</p> In\u00a0[\u00a0]: Copied! <pre>def on_pre_build(config: Config) -&gt; None:\n    \"\"\"\n    Before the build starts.\n    \"\"\"\n</pre> def on_pre_build(config: Config) -&gt; None:     \"\"\"     Before the build starts.     \"\"\""},{"location":"plugins/griffe_doclinks/","title":"Griffe doclinks","text":"<p>@Author  : Shuang (Twist) Song @Contact   : SongshGeo@gmail.com GitHub   : https://github.com/SongshGeo Website: https://cv.songshgeo.com/</p> In\u00a0[\u00a0]: Copied! <pre># refer: https://github.com/pydantic/pydantic/blob/main/docs/plugins/griffe_doclinks.py\nimport ast\nimport re\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Tuple\n</pre> # refer: https://github.com/pydantic/pydantic/blob/main/docs/plugins/griffe_doclinks.py import ast import re from functools import partial from pathlib import Path from typing import Tuple In\u00a0[\u00a0]: Copied! <pre>from griffe.dataclasses import Object as GriffeObject\nfrom griffe.extensions import VisitorExtension\nfrom pymdownx.slugs import slugify\n</pre> from griffe.dataclasses import Object as GriffeObject from griffe.extensions import VisitorExtension from pymdownx.slugs import slugify In\u00a0[\u00a0]: Copied! <pre>DOCS_PATH = Path(__file__).parent.parent\nslugifier = slugify(case=\"lower\")\n</pre> DOCS_PATH = Path(__file__).parent.parent slugifier = slugify(case=\"lower\") In\u00a0[\u00a0]: Copied! <pre>def find_heading(content: str, slug: str, file_path: Path) -&gt; Tuple[str, int]:\n    for m in re.finditer(\"^#+ (.+)\", content, flags=re.M):\n        heading = m.group(1)\n        h_slug = slugifier(heading, \"-\")\n        if h_slug == slug:\n            return heading, m.end()\n    raise ValueError(f\"heading with slug {slug!r} not found in {file_path}\")\n</pre> def find_heading(content: str, slug: str, file_path: Path) -&gt; Tuple[str, int]:     for m in re.finditer(\"^#+ (.+)\", content, flags=re.M):         heading = m.group(1)         h_slug = slugifier(heading, \"-\")         if h_slug == slug:             return heading, m.end()     raise ValueError(f\"heading with slug {slug!r} not found in {file_path}\") In\u00a0[\u00a0]: Copied! <pre>def insert_at_top(path: str, api_link: str) -&gt; str:\n    rel_file = path.rstrip(\"/\") + \".md\"\n    file_path = DOCS_PATH / rel_file\n    content = file_path.read_text()\n    second_heading = re.search(\"^#+ \", content, flags=re.M)\n    assert second_heading, \"unable to find second heading in file\"\n    first_section = content[: second_heading.start()]\n\n    if f\"[{api_link}]\" not in first_section:\n        print(\n            f'inserting API link \"{api_link}\" at the top of {file_path.relative_to(DOCS_PATH)}'\n        )\n        file_path.write_text(\n            '??? api \"API Documentation\"\\n'\n            f\"    [`{api_link}`][{api_link}]&lt;br&gt;\\n\\n\"\n            f\"{content}\"\n        )\n\n    heading = file_path.stem.replace(\"_\", \" \").title()\n    return (\n        f'!!! abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file})\\n'\n    )\n</pre> def insert_at_top(path: str, api_link: str) -&gt; str:     rel_file = path.rstrip(\"/\") + \".md\"     file_path = DOCS_PATH / rel_file     content = file_path.read_text()     second_heading = re.search(\"^#+ \", content, flags=re.M)     assert second_heading, \"unable to find second heading in file\"     first_section = content[: second_heading.start()]      if f\"[{api_link}]\" not in first_section:         print(             f'inserting API link \"{api_link}\" at the top of {file_path.relative_to(DOCS_PATH)}'         )         file_path.write_text(             '??? api \"API Documentation\"\\n'             f\"    [`{api_link}`][{api_link}]\\n\\n\"             f\"{content}\"         )      heading = file_path.stem.replace(\"_\", \" \").title()     return (         f'!!! abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file})\\n'     ) In\u00a0[\u00a0]: Copied! <pre>def replace_links(m: re.Match, *, api_link: str) -&gt; str:\n    path_group = m.group(1)\n    if \"#\" not in path_group:\n        # no heading id, put the content at the top of the page\n        return insert_at_top(path_group, api_link)\n\n    usage_path, slug = path_group.split(\"#\", 1)\n    rel_file = usage_path.rstrip(\"/\") + \".md\"\n    file_path = DOCS_PATH / rel_file\n    content = file_path.read_text()\n    heading, heading_end = find_heading(content, slug, file_path)\n\n    next_heading = re.search(\"^#+ \", content[heading_end:], flags=re.M)\n    if next_heading:\n        next_section = content[\n            heading_end : heading_end + next_heading.start()\n        ]\n    else:\n        next_section = content[heading_end:]\n\n    if f\"[{api_link}]\" not in next_section:\n        print(\n            f'inserting API link \"{api_link}\" into {file_path.relative_to(DOCS_PATH)}'\n        )\n        file_path.write_text(\n            f\"{content[:heading_end]}\\n\\n\"\n            '??? api \"API Documentation\"\\n'\n            f\"    [`{api_link}`][{api_link}]&lt;br&gt;\"\n            f\"{content[heading_end:]}\"\n        )\n\n    return f'!!! abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n'\n</pre> def replace_links(m: re.Match, *, api_link: str) -&gt; str:     path_group = m.group(1)     if \"#\" not in path_group:         # no heading id, put the content at the top of the page         return insert_at_top(path_group, api_link)      usage_path, slug = path_group.split(\"#\", 1)     rel_file = usage_path.rstrip(\"/\") + \".md\"     file_path = DOCS_PATH / rel_file     content = file_path.read_text()     heading, heading_end = find_heading(content, slug, file_path)      next_heading = re.search(\"^#+ \", content[heading_end:], flags=re.M)     if next_heading:         next_section = content[             heading_end : heading_end + next_heading.start()         ]     else:         next_section = content[heading_end:]      if f\"[{api_link}]\" not in next_section:         print(             f'inserting API link \"{api_link}\" into {file_path.relative_to(DOCS_PATH)}'         )         file_path.write_text(             f\"{content[:heading_end]}\\n\\n\"             '??? api \"API Documentation\"\\n'             f\"    [`{api_link}`][{api_link}]\"             f\"{content[heading_end:]}\"         )      return f'!!! abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n' In\u00a0[\u00a0]: Copied! <pre>def update_docstring(obj: GriffeObject) -&gt; str:\n    return re.sub(\n        # https://absespy.github.io/ABSESpy/\n        r\"usage[\\-]docs: ?https://absespy.github.io/ABSESpy/.+?/(\\S+)\",\n        # r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?/(\\S+)',\n        partial(replace_links, api_link=obj.path),\n        obj.docstring.value,\n        flags=re.I,\n    )\n</pre> def update_docstring(obj: GriffeObject) -&gt; str:     return re.sub(         # https://absespy.github.io/ABSESpy/         r\"usage[\\-]docs: ?https://absespy.github.io/ABSESpy/.+?/(\\S+)\",         # r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?/(\\S+)',         partial(replace_links, api_link=obj.path),         obj.docstring.value,         flags=re.I,     ) In\u00a0[\u00a0]: Copied! <pre>def update_docstrings_recursively(obj: GriffeObject) -&gt; None:\n    if obj.docstring:\n        obj.docstring.value = update_docstring(obj)\n    for member in obj.members.values():\n        if not member.is_alias:\n            update_docstrings_recursively(member)\n</pre> def update_docstrings_recursively(obj: GriffeObject) -&gt; None:     if obj.docstring:         obj.docstring.value = update_docstring(obj)     for member in obj.members.values():         if not member.is_alias:             update_docstrings_recursively(member) In\u00a0[\u00a0]: Copied! <pre>class Extension(VisitorExtension):\n    def visit_module(self, node: ast.AST) -&gt; None:\n        module = self.visitor.current.module\n        update_docstrings_recursively(module)\n</pre> class Extension(VisitorExtension):     def visit_module(self, node: ast.AST) -&gt; None:         module = self.visitor.current.module         update_docstrings_recursively(module)"},{"location":"tutorial/user_guide/","title":"user_guide","text":""},{"location":"tutorial/user_guide/#structures","title":"Structures","text":"<p>The overall structure of <code>ABSESpy</code> is shown in the following diagram:</p> <p></p> <p>Three main components <code>BaseHuman</code>, <code>BaseNature</code> and <code>MainModel</code> are included. Generally, users need to write their <code>sub-modules</code> for the operation of ecosystems or the operation of social systems, as well as the behaviour of <code>actors</code>. Once the model has been developed, the <code>mediator</code> will coordinate the running of the model and output the simulation to a log. The <code>Experiment</code> helps the user run the model to perform sensitivity of specific parameters.</p>"},{"location":"tutorial/user_guide/#model","title":"Model","text":"<ul> <li>First of all, get started with a simple model demo.</li> <li>Management of model parameters using <code>yaml</code> configuration files.</li> </ul>"},{"location":"tutorial/user_guide/#nature","title":"Nature","text":"<ul> <li>Load the geographic dataset as the space in which the subject operates and the patch variables that the subject can access based on its location.</li> <li>Manipulate <code>Patch</code> object for better spatial analysis</li> </ul>"},{"location":"tutorial/user_guide/#human","title":"Human","text":"<ul> <li>Understanding of the structure of the <code>ABSESpy</code> management and storage <code>Actor</code> (i.e., agents)</li> <li>Defining the collections of actors, rules of action, perception ... as if they were real people</li> <li>Applying Cognition, Contagion and behavioral Response (CCR Framework) with <code>ABSESpy</code>, here is an demo model.</li> </ul>"},{"location":"tutorial/user_guide/#experiment","title":"Experiment","text":"<ul> <li>Run the model repeatedly to test the sensitivity of a parameter. This function from agentpy is used. Please refer to here.</li> </ul>"},{"location":"tutorial/advanced/add_modules/","title":"Add modules","text":"<p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p>"},{"location":"tutorial/beginner/hotelling_full/","title":"Introducing the ABSESpy package","text":"<ul> <li>Introduction to the ABSESpy package</li> <li>Context and motivation (Explain Hotelling's Law)</li> <li>Model setup</li> <li>Model level methods</li> <li>Agent level methods</li> <li>Visualizations and model metrics</li> </ul> <p>The following introduces the ABSESpy python package for individual-based simulations in the context ofsocial-ecological systems. The package is designed to loose integrate societal elements as well as environmental ones. In order to follow the tutorial, please make sure that you have it installed.</p> <pre><code>%pip install --upgrade abses\"\n</code></pre> <p>This introduction presents the basic structure of the package and its main components by means of building a simple model, illustrating each step of the process. The model chosen is an adaptation of the Hotelling's Law model. The counterpart written in Netlogo can be found here. The Hotelling's Law, also referred to as the Law of minimum differentiation states that profit maximizing firms competing in a market with two substitute goods will settle close to each other and also lower their prices. Although the notion of distance related to space both in the original paper by Hotelling (1929) and its netlogo implementation, its definition can be expanded to other dimensions of interest.</p> In\u00a0[1]: Copied! <pre>import numpy as np\n\nfrom abses import Actor, MainModel\n\n# Instantiate a random number generator\nrng = np.random.default_rng()\n\n\n# Calculate euclidean distance between two points\ndef euclidean_distance(x1, y1, x2, y2):\n    return np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n</pre> import numpy as np  from abses import Actor, MainModel  # Instantiate a random number generator rng = np.random.default_rng()   # Calculate euclidean distance between two points def euclidean_distance(x1, y1, x2, y2):     return np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) In\u00a0[2]: Copied! <pre>class Shop(Actor):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.price = 10\n        self.area_count = 0\n        self.id = rng.integers(\n            1e6, 1e7\n        )  # FIXME: no two agents should have the same id\n        # cached results\n        self.next_position = None\n        self.next_price = None\n\n    def __repr__(self):\n        return f\"Shop {self.id}\"\n\n    def step(self):\n        self.adjust_price()\n        self.adjust_position()\n\n    def advance(self):\n        self.affect_price()\n        self.affect_position()\n\n    def adjust_price(self):\n        # Save initial price\n        initial_price = self.price\n\n        # Build a list of all possible prices\n        _possible_prices = [self.price - 1, self.price, self.price + 1]\n\n        # Pair each possible price change to its potential revenue\n        _potential_revenues = {}\n        for price in _possible_prices:\n            self.price = price\n            _potential_revenues[price] = (\n                self.model.recalculate_areas()[self] * price\n            )\n        # Check if all potential revenues are 0\n        # if so, decrease price by 1\n        if all(value == 0 for value in _potential_revenues.values()):\n            self.next_price = self.price - 1\n        # Otherwise, choose the price with the highest potential revenue\n        else:\n            self.next_price = max(\n                _potential_revenues, key=_potential_revenues.get\n            )\n\n        # Reset price to initial price\n        self.price = initial_price\n\n    def adjust_position(self):\n        # Save initial position\n        initial_pos = self.pos\n\n        # Get all possible candidates for the next position\n        _possible_moves = self.model.nature.major_layer.get_neighborhood(\n            self.pos, moore=True, include_center=False\n        )\n        # Pair each possible move to their potential areas\n        _potential_areas = {}\n        for move in _possible_moves:\n            self.move_to(move)\n            _potential_areas[move] = self.model.recalculate_areas()[self]\n\n        # Single out the store with the highest potential area and savi it\n        _choice = max(_potential_areas, key=_potential_areas.get)\n        self.next_position = _choice\n\n        # Pull back to initial position if the potential area\n        self.move_to(initial_pos)\n\n    def affect_price(self):\n        self.price = self.next_price\n\n    def affect_position(self):\n        self.move_to(self.next_position)\n</pre> class Shop(Actor):     def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.price = 10         self.area_count = 0         self.id = rng.integers(             1e6, 1e7         )  # FIXME: no two agents should have the same id         # cached results         self.next_position = None         self.next_price = None      def __repr__(self):         return f\"Shop {self.id}\"      def step(self):         self.adjust_price()         self.adjust_position()      def advance(self):         self.affect_price()         self.affect_position()      def adjust_price(self):         # Save initial price         initial_price = self.price          # Build a list of all possible prices         _possible_prices = [self.price - 1, self.price, self.price + 1]          # Pair each possible price change to its potential revenue         _potential_revenues = {}         for price in _possible_prices:             self.price = price             _potential_revenues[price] = (                 self.model.recalculate_areas()[self] * price             )         # Check if all potential revenues are 0         # if so, decrease price by 1         if all(value == 0 for value in _potential_revenues.values()):             self.next_price = self.price - 1         # Otherwise, choose the price with the highest potential revenue         else:             self.next_price = max(                 _potential_revenues, key=_potential_revenues.get             )          # Reset price to initial price         self.price = initial_price      def adjust_position(self):         # Save initial position         initial_pos = self.pos          # Get all possible candidates for the next position         _possible_moves = self.model.nature.major_layer.get_neighborhood(             self.pos, moore=True, include_center=False         )         # Pair each possible move to their potential areas         _potential_areas = {}         for move in _possible_moves:             self.move_to(move)             _potential_areas[move] = self.model.recalculate_areas()[self]          # Single out the store with the highest potential area and savi it         _choice = max(_potential_areas, key=_potential_areas.get)         self.next_position = _choice          # Pull back to initial position if the potential area         self.move_to(initial_pos)      def affect_price(self):         self.price = self.next_price      def affect_position(self):         self.move_to(self.next_position) In\u00a0[3]: Copied! <pre>class Hotelling(MainModel):\n    def __init__(self, N, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.num_agents = N\n\n    def setup(self):\n        # Initialize a grid of shape (12, 12)\n        self.nature.create_module(how=\"from_resolution\", shape=(12, 12))\n\n        # Create a list of agents\n        self.agents.create(Shop, self.num_agents)\n\n        # Placed agents on the grid randomly\n        positions = rng.integers(12, size=(self.num_agents, 2), dtype=np.int8)\n\n        for i, agent in enumerate(self.actors):\n            agent.put_on_layer(\n                layer=self.nature.major_layer, pos=tuple(positions[i])\n            )\n\n    def step(self):\n        # recalculate areas and assign them to each agent\n        areas = self.recalculate_areas()\n\n        for shop in self.actors:\n            shop.area_count = areas[shop]\n\n        # trigger all agents to step\n        self.actors.trigger(\"step\")\n\n        # let price and positional changes take effect\n        self.actors.trigger(\"advance\")\n\n    def recalculate_areas(self):\n        areas = {}\n\n        for shop in self.actors:\n            areas[shop] = 0\n\n        _width = self.nature.major_layer.width  # columns\n        _height = self.nature.major_layer.height  # rows\n\n        for i in range(_height):\n            for j in range(_width):\n                dist = {}\n                for shop in self.actors:\n                    _dist = (\n                        euclidean_distance(i, j, shop.pos[0], shop.pos[1])\n                        + shop.price\n                    )\n                    dist[shop] = _dist\n                _choice = min(dist, key=dist.get)\n                areas[_choice] += 1\n\n        return areas\n</pre> class Hotelling(MainModel):     def __init__(self, N, *args, **kwargs):         super().__init__(*args, **kwargs)         self.num_agents = N      def setup(self):         # Initialize a grid of shape (12, 12)         self.nature.create_module(how=\"from_resolution\", shape=(12, 12))          # Create a list of agents         self.agents.create(Shop, self.num_agents)          # Placed agents on the grid randomly         positions = rng.integers(12, size=(self.num_agents, 2), dtype=np.int8)          for i, agent in enumerate(self.actors):             agent.put_on_layer(                 layer=self.nature.major_layer, pos=tuple(positions[i])             )      def step(self):         # recalculate areas and assign them to each agent         areas = self.recalculate_areas()          for shop in self.actors:             shop.area_count = areas[shop]          # trigger all agents to step         self.actors.trigger(\"step\")          # let price and positional changes take effect         self.actors.trigger(\"advance\")      def recalculate_areas(self):         areas = {}          for shop in self.actors:             areas[shop] = 0          _width = self.nature.major_layer.width  # columns         _height = self.nature.major_layer.height  # rows          for i in range(_height):             for j in range(_width):                 dist = {}                 for shop in self.actors:                     _dist = (                         euclidean_distance(i, j, shop.pos[0], shop.pos[1])                         + shop.price                     )                     dist[shop] = _dist                 _choice = min(dist, key=dist.get)                 areas[_choice] += 1          return areas In\u00a0[4]: Copied! <pre>INITIALIZE = True\n\nparameters = {\n    \"time\": {\n        \"end\": 100,\n    }\n}\n\nif INITIALIZE:\n    model = Hotelling(N=2, parameters=parameters)\n\nmodel.run_model()\n</pre> INITIALIZE = True  parameters = {     \"time\": {         \"end\": 100,     } }  if INITIALIZE:     model = Hotelling(N=2, parameters=parameters)  model.run_model() <pre>2023-11-09 20:52:08.704 | DEBUG    | abses.time:_parse_time_settings:226 - start_dt: 2023-11-09T20:52:08.704362\n2023-11-09 20:52:08.706 | DEBUG    | abses.time:_parse_time_settings:230 - end_dt: 100\n2023-11-09 20:52:08.707 | DEBUG    | abses.time:_parse_time_settings:234 - duration: None\n2023-11-09 20:52:08.708 | DEBUG    | abses.time:_parse_time_settings:238 - irregular: None\n2023-11-09 20:52:08.709 | DEBUG    | abses.time:_parse_time_settings:239 - Ticking mode: tick\n</pre> <pre>tick[1] 2023-11-09 20:52:08tick[100] 2023-11-09 20:52:08</pre>"},{"location":"tutorial/beginner/hotelling_full/#introducing-the-absespy-package","title":"Introducing the ABSESpy package\u00b6","text":""},{"location":"tutorial/beginner/hotelling_tutorial/","title":"Introducing the ABSESpy package","text":"<p>The following introduces the ABSESpy python package for individual-based simulations in the context of social-ecological systems. The package is designed to loosely integrate societal elements as well as environmental ones. In order to follow the tutorial, please make sure that you have it properly installed.</p> <pre><code>%pip install --upgrade abses\"\n</code></pre> <p>This introduction presents the basic structure of the package and its main components by means of building a simple model, illustrating each step of the process. The model chosen is an adaptation of the Hotelling's Law model. The counterpart written in Netlogo can be found here. The Hotelling's Law, also referred to as the Law of minimum differentiation states that profit maximizing firms competing in a market with two substitute goods will settle close to each other and also lower their prices. Although the notion of distance relates to space both in the original paper by Hotelling (1929) and its netlogo implementation, its definition can be expanded to other dimensions of interest.</p> <p>At the base of any ABSESpy model, there will be a Model instance and as many Actor instances as desired. For the following example we will require that there is a specific hotelling model class that will inherit from the base MainModel class. This class will contain all the specific methods and attributes that are required for the model to run. In this case, we will need to define the following:</p> <ul> <li>Clearly defined setup method</li> <li>Clearly defined step method</li> <li>Other functionalities to assist the setup and step method.</li> </ul> <p>We will also need an class that inherits from Actor. We will call it shop to honor the original Hotelling's Law model and its netlogo implementation. For this class we will also write a setup and step method along with other functionalities that will be required for the model to run.</p> In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\nfrom abses import Actor, MainModel\n\n# Define random number generator\nrng = numpy.random.default_rng(seed=42)\n\n\nclass Shop(Actor):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass Hotelling(MainModel):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n</pre> import numpy as np  from abses import Actor, MainModel  # Define random number generator rng = numpy.random.default_rng(seed=42)   class Shop(Actor):     def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)   class Hotelling(MainModel):     def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs) <p>Following the netlogo implementation, each agent will begin at a random position. It will have a market area or share depending on its price and position. Each cell or patch of the grid is considered a customer with inelastic demand for the product. Each customer will make a choice as to what shop is prefered based on the price and distance to each shop. In the original paper (1929) the distance to the shop introduces transportation costs.</p> <p>We first may wish to work out all the setup before writing the instructions for each step.</p> <p>Drawing attention to the Shop agent class first, we will put in place some class attributes as we initialize the class. We are going to take <code>__init__</code> method as our setup step. We will give our Shop agent the following parameters:</p> attribute description price Agent's price area_count Number of customer who prefer the shop id Shop's identifier next_position Position to advance to at the end of this period next_price Price to set at the end of this period <p>The main control variables are the price and position. Area count is a variable that will be used by the agent to decide how to adjust its price and position but it won't be able to alter it. The agent's id is a unique 7-figure identifier. The next position and next price are the variables that will be used to store the agent's choices on position and price momentarily and that will take effect at the end of the period.</p> In\u00a0[\u00a0]: Copied! <pre>class Shop(Actor):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.price = 10\n        self.area_count = 0\n        self.id = rng.integers(\n            1e6, 1e7, dtype=int  # FIXME: no two agent may have the same id\n        )\n        self.next_position = None\n        self.next_price = None\n</pre> class Shop(Actor):     def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.price = 10         self.area_count = 0         self.id = rng.integers(             1e6, 1e7, dtype=int  # FIXME: no two agent may have the same id         )         self.next_position = None         self.next_price = None <p>In the case of the model object, the setup method has to be defined and it will be a bit more elaborate. As we initialize a model, we just want to pass one parameter to be stored as an attribute. This parameter is the number of shops that we want to have in the model.</p> <p>In the setup method we will want to i. initialize a grid, ii. create the list of agents and iii. place the agents in the grid randomly. To perform these actions, ABSESpy provides extensive functionality as to make it seamless and quick. It is important, nonetheless, to become familiar with involved modules. Namely, there are two that are of interest for us now:</p> <ol> <li>BaseNature</li> <li>ActorsList</li> </ol> <p>They are both used under the hood in the initialization of the model object. BaseNature provides us with the spatial component for our model. ActorsList is the container of all agents in the model.</p> In\u00a0[\u00a0]: Copied! <pre>class Hotelling(MainModel):\n    def __init__(self, N, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.num_agents = N\n\n    def setup(self):\n        # Initialize a grid of shape (12, 12)\n        self.nature.create_module(how=\"from_resolution\", shape=(12, 12))\n\n        # Create a list of agents\n        self.agents.create(Shop, self.num_agents)\n\n        # Placed agents on the grid randomly\n        positions = rng.integers(12, size=(self.num_agents, 2), dtype=np.int8)\n\n        for i, agent in enumerate(self.actors):\n            agent.put_on_layer(\n                layer=self.nature.major_layer, pos=tuple(positions[i])\n            )\n</pre> class Hotelling(MainModel):     def __init__(self, N, *args, **kwargs):         super().__init__(*args, **kwargs)         self.num_agents = N      def setup(self):         # Initialize a grid of shape (12, 12)         self.nature.create_module(how=\"from_resolution\", shape=(12, 12))          # Create a list of agents         self.agents.create(Shop, self.num_agents)          # Placed agents on the grid randomly         positions = rng.integers(12, size=(self.num_agents, 2), dtype=np.int8)          for i, agent in enumerate(self.actors):             agent.put_on_layer(                 layer=self.nature.major_layer, pos=tuple(positions[i])             ) <p>The <code>step</code> method of the <code>Hotelling</code> model class is responsible for updating the state of the model at each time step. It will first call the a method to calculate the monopoly areas for each shop, and then assigns the area count to each shop. The reasoning being that at the end of each step all agents decisions will have affected the state of the environment, thus, we recalculate variables that are affected by changes instantiated by those decisions and update them. It then triggers all agents to step. Finally, it triggers the price and positional changes to take effect using the <code>advance</code> method each agent should have.</p> <p>Notice how we are already making choices that will affect how the model will be further developed. For instance, now we now that our Shop agents should have, at least, two methods: one named <code>step</code> and another named <code>advance</code>. Also, the next step should consist of implementing the monopoly area calculation method.</p> In\u00a0[\u00a0]: Copied! <pre>class Hotelling(MainModel):\n    def __init__(self, N, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.num_agents = N\n\n    def setup(self):\n        # Initialize a grid of shape (12, 12)\n        self.nature.create_module(how=\"from_resolution\", shape=(12, 12))\n\n        # Create a list of agents\n        self.agents.create(Shop, self.num_agents)\n\n        # Placed agents on the grid randomly\n        positions = rng.integers(12, size=(self.num_agents, 2), dtype=np.int8)\n\n        for i, agent in enumerate(self.actors):\n            agent.put_on_layer(\n                layer=self.nature.major_layer, pos=tuple(positions[i])\n            )\n\n    def step(self):\n        # recalculate areas and assign them to each agent\n        areas = self.recalculate_areas()\n\n        for shop in self.actors:\n            shop.area_count = areas[shop]\n\n        # trigger all agents to step\n        self.actors.trigger(\"step\")\n\n        # let price and positional changes take effect\n        self.actors.trigger(\"advance\")\n\n    def recalculate_areas(self):\n        pass\n</pre> class Hotelling(MainModel):     def __init__(self, N, *args, **kwargs):         super().__init__(*args, **kwargs)         self.num_agents = N      def setup(self):         # Initialize a grid of shape (12, 12)         self.nature.create_module(how=\"from_resolution\", shape=(12, 12))          # Create a list of agents         self.agents.create(Shop, self.num_agents)          # Placed agents on the grid randomly         positions = rng.integers(12, size=(self.num_agents, 2), dtype=np.int8)          for i, agent in enumerate(self.actors):             agent.put_on_layer(                 layer=self.nature.major_layer, pos=tuple(positions[i])             )      def step(self):         # recalculate areas and assign them to each agent         areas = self.recalculate_areas()          for shop in self.actors:             shop.area_count = areas[shop]          # trigger all agents to step         self.actors.trigger(\"step\")          # let price and positional changes take effect         self.actors.trigger(\"advance\")      def recalculate_areas(self):         pass <p>We will want to be able to calculate respective monopoly areas for each shop. Since no single agent can really set this variable for himself, this method must be implement within the scope of the Hotelling model class scope. Essentially, it will iterate through each path or cell and it will define what would be the preferred shop for a customer that sits on that cell. The area for any given Shop is the number of customer that prefer that shop.</p> <p>We are going to need a function to calculate the distance between any two points in the grid. We will use the euclidean distance. We proceed to take this distance as the nominal value of the transportation costs, assuming each unit of distance equates one unit of money.</p> <p>This distance plus the price will define the total costs that a customer incurs when buying from a given shop.</p> <p>The preferred shop will be the cheapest one. That is, the one for which the customer faces less costs for both the product itself and transportation. The method will return a dictionary with the number of customers that prefer each shop.</p> <p>Once it is done, we already should have finished the implementation of the Model class. It is important to note that the model class requires the setup and step methods since those control the most fundamental and basic aspects of the simulation. Further functionality may be added depending on the idiosyncratic needs of the researcher. In our case, we aim to keep things as simple as possible and only add a method to calculate each shops respective control areas since that variables should be given to the agents and taken as given by them.</p> In\u00a0[\u00a0]: Copied! <pre># Calculate euclidean distance between two points\ndef euclidean_distance(x1, y1, x2, y2):\n    return np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n</pre> # Calculate euclidean distance between two points def euclidean_distance(x1, y1, x2, y2):     return np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) In\u00a0[\u00a0]: Copied! <pre>class Hotelling(MainModel):\n    def __init__(self, N, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.num_agents = N\n\n    def setup(self):\n        # Initialize a grid of shape (12, 12)\n        self.nature.create_module(how=\"from_resolution\", shape=(12, 12))\n\n        # Create a list of agents\n        self.agents.create(Shop, self.num_agents)\n\n        # Placed agents on the grid randomly\n        positions = rng.integers(12, size=(self.num_agents, 2), dtype=np.int8)\n\n        for i, agent in enumerate(self.actors):\n            agent.put_on_layer(\n                layer=self.nature.major_layer, pos=tuple(positions[i])\n            )\n\n    def step(self):\n        # recalculate areas and assign them to each agent\n        areas = self.recalculate_areas()\n\n        for shop in self.actors:\n            shop.area_count = areas[shop]\n\n        # trigger all agents to step\n        self.actors.trigger(\"step\")\n\n        # let price and positional changes take effect\n        self.actors.trigger(\"advance\")\n\n    def recalculate_areas(self):\n        areas = {}\n\n        for shop in self.actors:\n            areas[shop] = 0\n\n        _width = self.nature.major_layer.width  # columns\n        _height = self.nature.major_layer.height  # rows\n\n        for i in range(_height):\n            for j in range(_width):\n                dist = {}\n                for shop in self.actors:\n                    _dist = (\n                        euclidean_distance(i, j, shop.pos[0], shop.pos[1])\n                        + shop.price\n                    )\n                    dist[shop] = _dist\n                _choice = min(dist, key=dist.get)\n                areas[_choice] += 1\n\n        return areas\n</pre> class Hotelling(MainModel):     def __init__(self, N, *args, **kwargs):         super().__init__(*args, **kwargs)         self.num_agents = N      def setup(self):         # Initialize a grid of shape (12, 12)         self.nature.create_module(how=\"from_resolution\", shape=(12, 12))          # Create a list of agents         self.agents.create(Shop, self.num_agents)          # Placed agents on the grid randomly         positions = rng.integers(12, size=(self.num_agents, 2), dtype=np.int8)          for i, agent in enumerate(self.actors):             agent.put_on_layer(                 layer=self.nature.major_layer, pos=tuple(positions[i])             )      def step(self):         # recalculate areas and assign them to each agent         areas = self.recalculate_areas()          for shop in self.actors:             shop.area_count = areas[shop]          # trigger all agents to step         self.actors.trigger(\"step\")          # let price and positional changes take effect         self.actors.trigger(\"advance\")      def recalculate_areas(self):         areas = {}          for shop in self.actors:             areas[shop] = 0          _width = self.nature.major_layer.width  # columns         _height = self.nature.major_layer.height  # rows          for i in range(_height):             for j in range(_width):                 dist = {}                 for shop in self.actors:                     _dist = (                         euclidean_distance(i, j, shop.pos[0], shop.pos[1])                         + shop.price                     )                     dist[shop] = _dist                 _choice = min(dist, key=dist.get)                 areas[_choice] += 1          return areas <p>Now we shift out attention to the Shop agent class. From the previous implementation of the Hotelling model class, we already have cues as to what we should aim for and tackle. We know there must be a step and an advance method. We also know that the agent must make a decision regarding price and position based on the number of customer that prefer buying from them, thus, increasing profits and staying in business. Therefore, we will design the Shop agent class in a way that reflect this. There will be the two methods already mentioned and for each there will be two routines.</p> <p>First, the <code>step</code> method will be called for all agents. In it, there will be two routines regarding the changes in prices and positions respectively. At each step, each agent is going to adjust its price and position, but those changes will only take effect at a later stage. The reason for this is that we want to make sure that all agents have made their decisions before any of them takes effect. This may also be referred to as a synchronous or simultaneous update. In order to do that, we want to save the changes in a variable that will be used to update the agent's attributes at the end of the step. This is the reason behing having the <code>next_price</code> and <code>next_position</code> attributes.</p> In\u00a0[\u00a0]: Copied! <pre>class Shop(Actor):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.price = 10\n        self.area_count = 0\n        self.id = rng.integers(\n            1e6, 1e7, dtype=int  # FIXME: no two agent may have the same id\n        )\n        self.next_position = None\n        self.next_price = None\n\n    def step(self):\n        self.adjust_price()\n        self.adjust_position()\n\n    def advance(self):\n        self.affect_price()\n        self.affect_position()\n\n    def adjust_price(self):\n        pass\n\n    def adjust_position(self):\n        pass\n\n    def affect_price(self):\n        pass\n\n    def affect_position(self):\n        pass\n</pre> class Shop(Actor):     def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.price = 10         self.area_count = 0         self.id = rng.integers(             1e6, 1e7, dtype=int  # FIXME: no two agent may have the same id         )         self.next_position = None         self.next_price = None      def step(self):         self.adjust_price()         self.adjust_position()      def advance(self):         self.affect_price()         self.affect_position()      def adjust_price(self):         pass      def adjust_position(self):         pass      def affect_price(self):         pass      def affect_position(self):         pass <p>The price adjustme schedule are part of the <code>Shop</code> class in the Hotelling model. There are two methods that relate to this procedure, namely, <code>adjust_price</code> and <code>adjust_position</code>. Here's a detailed description of how it works:</p> <ol> <li><p>adjust_price: This method is responsible for determining the next price for the shop based on potential revenues.</p> <ul> <li><p>It first saves the current price of the shop in <code>initial_price</code>.</p> </li> <li><p>It then creates a list of possible prices, which are the current price minus 1, the current price, and the current price plus 1.</p> </li> <li><p>For each possible price, it temporarily sets the shop's price to that value and calculates the potential revenue if the shop were to sell at that price. The potential revenue is calculated as the product of the price and the area of the shop's monopoly, which is obtained by calling the <code>recalculate_areas</code> method of the model.</p> </li> <li><p>If all potential revenues are 0, it sets <code>next_price</code> to be the current price minus 1. This means that if the shop cannot make any revenue at any of the possible prices, it will lower its price in the next step.</p> </li> <li><p>If there is at least one possible price that can generate revenue, it sets <code>next_price</code> to be the one that generates the highest potential revenue.</p> </li> <li><p>Finally, it resets the shop's price to the initial price. This is because the actual price change does not occur in the <code>adjust_price</code> method. Instead, the new price is stored in <code>next_price</code> and the price change is applied in the <code>affect_price</code> method.</p> </li> </ul> </li> <li><p>affect_price: This method is responsible for applying the price change that was determined in the <code>adjust_price</code> method.</p> <ul> <li>It simply sets the shop's price to <code>next_price</code>. This is the new price that was determined in the <code>adjust_price</code> method.</li> </ul> </li> </ol> <p>The <code>adjust_price</code> and <code>affect_price</code> methods are called in the <code>step</code> and <code>advance</code> methods of the <code>Shop</code> class, respectively. This allows all shops to make their decisions based on the current state of the model in the <code>step</code> method, and then all decisions are applied simultaneously in the <code>advance</code> method.</p> In\u00a0[\u00a0]: Copied! <pre>class Shop(Actor):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.price = 10\n        self.area_count = 0\n        self.id = rng.integers(\n            1e6, 1e7, dtype=int  # FIXME: no two agent may have the same id\n        )\n        self.next_position = None\n        self.next_price = None\n\n    def step(self):\n        self.adjust_price()\n        self.adjust_position()\n\n    def advance(self):\n        self.affect_price()\n        self.affect_position()\n\n    def adjust_price(self):\n        # Save initial price\n        initial_price = self.price\n\n        # Build a list of all possible prices\n        _possible_prices = [self.price - 1, self.price, self.price + 1]\n\n        # Pair each possible price change to its potential revenue\n        _potential_revenues = {}\n        for price in _possible_prices:\n            self.price = price\n            _potential_revenues[price] = (\n                self.model.recalculate_areas()[self] * price\n            )\n        # Check if all potential revenues are 0\n        # if so, decrease price by 1\n        if all(value == 0 for value in _potential_revenues.values()):\n            self.next_price = self.price - 1\n        # Otherwise, choose the price with the highest potential revenue\n        else:\n            self.next_price = max(\n                _potential_revenues, key=_potential_revenues.get\n            )\n\n        # Reset price to initial price\n        self.price = initial_price\n\n    def adjust_position(self):\n        pass\n\n    def affect_price(self):\n        self.price = self.next_price\n\n    def affect_position(self):\n        pass\n</pre> class Shop(Actor):     def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.price = 10         self.area_count = 0         self.id = rng.integers(             1e6, 1e7, dtype=int  # FIXME: no two agent may have the same id         )         self.next_position = None         self.next_price = None      def step(self):         self.adjust_price()         self.adjust_position()      def advance(self):         self.affect_price()         self.affect_position()      def adjust_price(self):         # Save initial price         initial_price = self.price          # Build a list of all possible prices         _possible_prices = [self.price - 1, self.price, self.price + 1]          # Pair each possible price change to its potential revenue         _potential_revenues = {}         for price in _possible_prices:             self.price = price             _potential_revenues[price] = (                 self.model.recalculate_areas()[self] * price             )         # Check if all potential revenues are 0         # if so, decrease price by 1         if all(value == 0 for value in _potential_revenues.values()):             self.next_price = self.price - 1         # Otherwise, choose the price with the highest potential revenue         else:             self.next_price = max(                 _potential_revenues, key=_potential_revenues.get             )          # Reset price to initial price         self.price = initial_price      def adjust_position(self):         pass      def affect_price(self):         self.price = self.next_price      def affect_position(self):         pass <p>Next we write the methods relating to the position adjustment schedule. Here's a detailed description of how they work:</p> <ol> <li><p>adjust_position: This method is responsible for determining the next position for the shop based on potential areas.</p> <ul> <li><p>It first saves the current position of the shop in <code>initial_pos</code>.</p> </li> <li><p>It then gets a list of all possible moves the shop can make. This is done by calling the <code>get_neighborhood</code> method of the <code>major_layer</code> attribute of the model, which returns the neighboring cells of the shop's current position. The <code>major_layer</code> is a BaseNature instance that represent one grid of the model.</p> </li> <li><p>For each possible move, it temporarily moves the shop to that position and calculates the potential area of the shop's monopoly if it were to move to that position. The potential area is calculated by calling the <code>recalculate_areas</code> method of the model.</p> </li> <li><p>It then selects the move that results in the largest potential area and stores it in <code>next_position</code>.</p> </li> <li><p>Finally, it moves the shop back to its initial position. This is because the actual move does not occur in the <code>adjust_position</code> method. Instead, the new position is stored in <code>next_position</code> and the move is applied in the <code>affect_position</code> method.</p> </li> </ul> </li> <li><p>affect_position: This method is responsible for applying the move that was determined in the <code>adjust_position</code> method.</p> <ul> <li>It simply moves the shop to <code>next_position</code>. This is the new position that was determined in the <code>adjust_position</code> method.</li> </ul> </li> </ol> <p>The <code>adjust_position</code> and <code>affect_position</code> methods are called in the <code>step</code> and <code>advance</code> methods of the <code>Shop</code> class, respectively. This allows all shops to make their decisions based on the current state of the model in the <code>step</code> method, and then all decisions are applied simultaneously in the <code>advance</code> method.</p> In\u00a0[\u00a0]: Copied! <pre>class Shop(Actor):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.price = 10\n        self.area_count = 0\n        self.id = rng.integers(\n            1e6, 1e7  # FIXME: no two agents should have the same id\n        )\n        self.next_position = None\n        self.next_price = None\n\n    def step(self):\n        self.adjust_price()\n        self.adjust_position()\n\n    def advance(self):\n        self.affect_price()\n        self.affect_position()\n\n    def adjust_price(self):\n        # Save initial price\n        initial_price = self.price\n\n        # Build a list of all possible prices\n        _possible_prices = [self.price - 1, self.price, self.price + 1]\n\n        # Pair each possible price change to its potential revenue\n        _potential_revenues = {}\n        for price in _possible_prices:\n            self.price = price\n            _potential_revenues[price] = (\n                self.model.recalculate_areas()[self] * price\n            )\n        # Check if all potential revenues are 0\n        # if so, decrease price by 1\n        if all(value == 0 for value in _potential_revenues.values()):\n            self.next_price = self.price - 1\n        # Otherwise, choose the price with the highest potential revenue\n        else:\n            self.next_price = max(\n                _potential_revenues, key=_potential_revenues.get\n            )\n\n        # Reset price to initial price\n        self.price = initial_price\n\n    def adjust_position(self):\n        # Save initial position\n        initial_pos = self.pos\n\n        # Get all possible candidates for the next position\n        _possible_moves = self.model.nature.major_layer.get_neighborhood(\n            self.pos, moore=True, include_center=False\n        )\n        # Pair each possible move to their potential areas\n        _potential_areas = {}\n        for move in _possible_moves:\n            self.move_to(move)\n            _potential_areas[move] = self.model.recalculate_areas()[self]\n\n        # Single out the store with the highest potential area and savi it\n        _choice = max(_potential_areas, key=_potential_areas.get)\n        self.next_position = _choice\n\n        # Pull back to initial position if the potential area\n        self.move_to(initial_pos)\n\n    def affect_price(self):\n        self.price = self.next_price\n\n    def affect_position(self):\n        self.move_to(self.next_position)\n</pre> class Shop(Actor):     def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.price = 10         self.area_count = 0         self.id = rng.integers(             1e6, 1e7  # FIXME: no two agents should have the same id         )         self.next_position = None         self.next_price = None      def step(self):         self.adjust_price()         self.adjust_position()      def advance(self):         self.affect_price()         self.affect_position()      def adjust_price(self):         # Save initial price         initial_price = self.price          # Build a list of all possible prices         _possible_prices = [self.price - 1, self.price, self.price + 1]          # Pair each possible price change to its potential revenue         _potential_revenues = {}         for price in _possible_prices:             self.price = price             _potential_revenues[price] = (                 self.model.recalculate_areas()[self] * price             )         # Check if all potential revenues are 0         # if so, decrease price by 1         if all(value == 0 for value in _potential_revenues.values()):             self.next_price = self.price - 1         # Otherwise, choose the price with the highest potential revenue         else:             self.next_price = max(                 _potential_revenues, key=_potential_revenues.get             )          # Reset price to initial price         self.price = initial_price      def adjust_position(self):         # Save initial position         initial_pos = self.pos          # Get all possible candidates for the next position         _possible_moves = self.model.nature.major_layer.get_neighborhood(             self.pos, moore=True, include_center=False         )         # Pair each possible move to their potential areas         _potential_areas = {}         for move in _possible_moves:             self.move_to(move)             _potential_areas[move] = self.model.recalculate_areas()[self]          # Single out the store with the highest potential area and savi it         _choice = max(_potential_areas, key=_potential_areas.get)         self.next_position = _choice          # Pull back to initial position if the potential area         self.move_to(initial_pos)      def affect_price(self):         self.price = self.next_price      def affect_position(self):         self.move_to(self.next_position) <p>Once we have a full working and testable version of our model, we instantiate it and run it. The following code block shows how to do this:</p> <ol> <li><p>Define the Parameters</p> <p>The <code>parameters</code> dictionary is defining the parameters for the simulation. In this case, there's only one parameter: <code>end</code>. This parameter is nested under <code>time</code> and is set to <code>100</code>. This means the simulation will run for 100 time steps.</p> </li> <li><p>Instantiate the Model</p> <p>The <code>Hotelling</code> model is being instantiated with <code>N=2</code> and <code>parameters=parameters</code>. This means that the model will start with 2 agents (as specified by <code>N=2</code>) and will use the parameters defined in the <code>parameters</code> dictionary.</p> </li> <li><p>Run the Model</p> <p>The <code>run_model</code> method is called on the <code>model</code> instance. This starts the simulation and runs it until the end time specified in the parameters (in this case, 100 time steps).</p> </li> </ol> <p>The <code>Hotelling</code> model is a type of agent-based model used in economics to simulate competition between two firms (or agents) in a geographical market. The <code>N=2</code> parameter suggests that there are two firms in the simulation. The firms adjust their prices and locations in each time step based on the state of the market, and the simulation tracks these adjustments over time.</p> In\u00a0[\u00a0]: Copied! <pre>parameters = {\n    \"time\": {\n        \"end\": 100,\n    }\n}\n\nmodel = Hotelling(N=2, parameters=parameters)\n\nmodel.run_model()\n</pre> parameters = {     \"time\": {         \"end\": 100,     } }  model = Hotelling(N=2, parameters=parameters)  model.run_model()"},{"location":"tutorial/beginner/hotelling_tutorial/#introducing-the-absespy-package","title":"Introducing the ABSESpy package\u00b6","text":""},{"location":"tutorial/beginner/use_example/","title":"usage","text":"<p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p>"},{"location":"tutorial/lessons/human_behavior_simulation/","title":"Advanced Human Behavior Simulation Framework","text":"<p>In the dynamic realm of Socio-Ecological Systems (SES) modeling, simulating human behavior is paramount. Humans, as key actors, play a pivotal role in shaping the interactions and outcomes within SES. Recognizing the complexity and nuances of human actions, ABSESpy introduces an advanced framework to model intricate human behaviors effectively.</p> <p>The beauty of ABSESpy lies in its framework that seamlessly integrates these user-defined functions, creating a smooth workflow that mirrors the intricacies of human behavior in the real world. When implementing this human behavior framework with ABSESpy, users are allowed to define key elements of decision-making step by step with the following concepts:</p> <ul> <li>Decision: First, define the types of decisions that an actor can make. A particular type of decision can be made by various types of actors. However, pre-defining what the decision types are helps users to better understand and organize their models.</li> <li>Perception: Actors make decisions based on their perception of the surrounding world, including both the natural and social environments.</li> <li>Evaluate: As the process of evaluating perceptions can vary, different actors may have different methods of evaluating decisions. Users can choose different evaluation methods for the same decision across various actors.</li> <li>Response: Finally, based on the decision-making process, actors respond and their actions impact the surrounding environment.</li> </ul> <p>Let's dive into them.</p> In\u00a0[1]: Copied! <pre>from abses import Actor\nfrom abses.actor import perception\nfrom abses.decision import Decision\nfrom abses.main import MainModel\nimport numpy as np\n\n\nclass OverWorking(Decision):\n    \"\"\"\u5185\u5377\u7b56\u7565\"\"\"\n\n    __strategies__ = {\n        True: \"Decide to work longer.\",\n        False: \"No longer work more...\",\n    }\n\n    def setup(self):\n        \"\"\"Initial strategy of a new actor.\"\"\"\n        return np.random.choice([True, False], p=[0.1, 0.9])\n</pre> from abses import Actor from abses.actor import perception from abses.decision import Decision from abses.main import MainModel import numpy as np   class OverWorking(Decision):     \"\"\"\u5185\u5377\u7b56\u7565\"\"\"      __strategies__ = {         True: \"Decide to work longer.\",         False: \"No longer work more...\",     }      def setup(self):         \"\"\"Initial strategy of a new actor.\"\"\"         return np.random.choice([True, False], p=[0.1, 0.9]) <p>A custom decision needs to inherit the <code>Decision</code> class, and users can customize the class attribute  <code>__strategies__</code> to set the choice of strategies and explanations for each strategy. The strategy does not need to be actively instantiated because a decision always requires a decision-making subject, which we will define next:</p> In\u00a0[2]: Copied! <pre>class InvolutingActor(Actor):\n    \"\"\"A poor guy who has to work harder...\"\"\"\n\n    __decisions__ = OverWorking\n\n\nmodel = MainModel()\nactor = InvolutingActor(model=model)\n</pre> class InvolutingActor(Actor):     \"\"\"A poor guy who has to work harder...\"\"\"      __decisions__ = OverWorking   model = MainModel() actor = InvolutingActor(model=model) <p>As you can see, it's very simple. When customizing the main class, all you need to do is set <code>__decisions__</code> in the class attributes. This type of main actors will automatically have this decision when initialized. You can access it using <code>decisions</code> or a shortcut <code>d</code>:</p> In\u00a0[3]: Copied! <pre>actor.decisions.over_working\n</pre> actor.decisions.over_working Out[3]: <pre>&lt;over_working: False&gt;</pre> In\u00a0[4]: Copied! <pre>actor.d.over_working\n</pre> actor.d.over_working Out[4]: <pre>&lt;over_working: False&gt;</pre> <p>Generally speaking, actors (i.e., agents) in socio-ecological systems (SES) need to base their decisions on their perception of the world.</p> <p>Let's create a agent who is tired from work, initially only working 7 hours a day. He will perceive the intensity of his colleagues' work around him.</p> In\u00a0[5]: Copied! <pre>class InvolutingActor(Actor):\n    \"\"\"A poor guy who has to work harder...\"\"\"\n\n    __decisions__ = OverWorking\n\n    def __init__(self, *args, working_hrs: float = 7.0, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.working_hrs = working_hrs\n        self.overwork = False\n\n    @perception\n    def avg_working_hrs(self) -&gt; float:\n        \"\"\"The average wealth of acquaintances.\"\"\"\n        colleagues = self.linked(\"colleague\")\n        return colleagues.array(\"working_hrs\").mean()\n</pre> class InvolutingActor(Actor):     \"\"\"A poor guy who has to work harder...\"\"\"      __decisions__ = OverWorking      def __init__(self, *args, working_hrs: float = 7.0, **kwargs) -&gt; None:         super().__init__(*args, **kwargs)         self.working_hrs = working_hrs         self.overwork = False      @perception     def avg_working_hrs(self) -&gt; float:         \"\"\"The average wealth of acquaintances.\"\"\"         colleagues = self.linked(\"colleague\")         return colleagues.array(\"working_hrs\").mean() <p>Now, let's create some agents and make them be colluague of our poor guy.</p> <p>We use <code>link_to</code> method to do so. The tutorial of this method can be found here.</p> In\u00a0[6]: Copied! <pre>agents = model.agents.create(InvolutingActor, 3)\npoor_guy, colleague_1, colleague_2 = agents\n\npoor_guy.working_hrs = 7\ncolleague_1.working_hrs = 8\ncolleague_2.working_hrs = 8\n\n# link_to() method can build links between agents and/or cells\npoor_guy.link_to(colleague_1, \"colleague\")\npoor_guy.link_to(colleague_2, \"colleague\")\n\npoor_guy.linked(\"colleague\")\n</pre> agents = model.agents.create(InvolutingActor, 3) poor_guy, colleague_1, colleague_2 = agents  poor_guy.working_hrs = 7 colleague_1.working_hrs = 8 colleague_2.working_hrs = 8  # link_to() method can build links between agents and/or cells poor_guy.link_to(colleague_1, \"colleague\") poor_guy.link_to(colleague_2, \"colleague\")  poor_guy.linked(\"colleague\") Out[6]: <pre>&lt;ActorsList: (2)InvolutingActor&gt;</pre> In\u00a0[7]: Copied! <pre># report the average working hours of its colleagues.\npoor_guy.avg_working_hrs()\n</pre> # report the average working hours of its colleagues. poor_guy.avg_working_hrs() Out[7]: <pre>8.0</pre> <p>After this entity perceives the average working hours of colleagues, it will conduct an evaluation. We can use the decorator class method <code>making</code> provided in the previously created decision <code>OverWork</code> to decorate the evaluation function. In this way, the output of this function will serve as the current strategy for that decision.</p> <pre>class InvolutingActor(Actor):\n    \"\"\"A poor guy who has to work harder...\"\"\"\n\n    # ... other methods ...\n\n    @OverWorking.making\n    def feel_peer_pressure(self):\n        \"\"\"Feel stressful when others work harder than self.\"\"\"\n        return self.working_hrs &lt;= self.avg_working_hrs()\n</pre> <p>Once a decision is made by the subject, a response (i.e., \"action\" in practical terms) will be generated. We have provided another decorator <code>response</code>, and users can use this decorator to logically specify what kind of action is produced under which strategy for which decision. It determines how agents respond to their decisions. This can involve moving to a new location, altering their state, or interacting with other entities. Here, let our class add a simple response when it \"feels peer pressure\" -i.e., work one hour more...:</p> <pre>class InvolutingActor(Actor):\n    \"\"\"A poor guy who has to work harder...\"\"\"\n\n    # ... other methods ...\n\n    @response(decision=\"over_working\", strategy=True)\n    def work_harder(self):\n        \"\"\"Work harder.\"\"\"\n        self.working_hrs += 1\n</pre> <p>Integrating the methods of the above-mentioned methods, we will get such a custom actor (agent) class <code>InvolutingActor</code> (in Chinese it is called \"\u5185\u5377\u7684\u4eba\", that is, a person who has to consume his own energy due to competitive pressure but does not make substantial progress.)</p> In\u00a0[8]: Copied! <pre>class InvolutingActor(Actor):\n    \"\"\"A poor guy who has to work harder...\"\"\"\n\n    __decisions__ = OverWorking\n\n    def __init__(self, *args, working_hrs: float = 7.0, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.working_hrs = working_hrs\n        self.overwork = False\n\n    @perception\n    def avg_working_hrs(self) -&gt; float:\n        \"\"\"The average wealth of acquaintances.\"\"\"\n        acquaintance = self.linked(\"colleague\")\n        return acquaintance.array(\"working_hrs\").mean()\n\n    @OverWorking.response(strategy=True)\n    def work_harder(self):\n        \"\"\"Work harder.\"\"\"\n        self.working_hrs += 1\n\n    @OverWorking.making\n    def feel_peer_pressure(self):\n        \"\"\"Feel stressful when others work harder than self.\"\"\"\n        return self.working_hrs &lt;= self.avg_working_hrs()\n</pre> class InvolutingActor(Actor):     \"\"\"A poor guy who has to work harder...\"\"\"      __decisions__ = OverWorking      def __init__(self, *args, working_hrs: float = 7.0, **kwargs) -&gt; None:         super().__init__(*args, **kwargs)         self.working_hrs = working_hrs         self.overwork = False      @perception     def avg_working_hrs(self) -&gt; float:         \"\"\"The average wealth of acquaintances.\"\"\"         acquaintance = self.linked(\"colleague\")         return acquaintance.array(\"working_hrs\").mean()      @OverWorking.response(strategy=True)     def work_harder(self):         \"\"\"Work harder.\"\"\"         self.working_hrs += 1      @OverWorking.making     def feel_peer_pressure(self):         \"\"\"Feel stressful when others work harder than self.\"\"\"         return self.working_hrs &lt;= self.avg_working_hrs() <p>Let's see what's happening now? We can use the <code>decision.making()</code> method of the actor, so that the subject will automatically complete the \"perception-&gt;evaluation-&gt;response\" framework. That is, this person involved in intense competition has automatically increased his working hours (from 7 to 8).</p> In\u00a0[9]: Copied! <pre>agents = model.agents.create(InvolutingActor, 3)\npoor_guy, colleague_1, colleague_2 = agents\n\npoor_guy.working_hrs = 7\ncolleague_1.working_hrs = 8\ncolleague_2.working_hrs = 7\n\n# link_to() method can build links between agents and/or cells\npoor_guy.link_to(colleague_1, \"colleague\")\npoor_guy.link_to(colleague_2, \"colleague\")\n\n# decision making...\npoor_guy.decisions.making()\n</pre> agents = model.agents.create(InvolutingActor, 3) poor_guy, colleague_1, colleague_2 = agents  poor_guy.working_hrs = 7 colleague_1.working_hrs = 8 colleague_2.working_hrs = 7  # link_to() method can build links between agents and/or cells poor_guy.link_to(colleague_1, \"colleague\") poor_guy.link_to(colleague_2, \"colleague\")  # decision making... poor_guy.decisions.making() In\u00a0[10]: Copied! <pre>poor_guy.working_hrs\n</pre> poor_guy.working_hrs Out[10]: <pre>8</pre> <p>Using <code>decisions.making</code> will automatically check all the decisions set by the subject and implement the \"perception-&gt;evaluation-&gt;response\" framework. If the decision result does not meet the conditions for generating a response, it will not respond. Look, when this poor person's working hours are no longer lower than the average of those around him, he no longer actively increases his own working hours from 8 to 9:</p> In\u00a0[11]: Copied! <pre>poor_guy.decisions.making()\npoor_guy.working_hrs\n</pre> poor_guy.decisions.making() poor_guy.working_hrs Out[11]: <pre>8</pre>"},{"location":"tutorial/lessons/human_behavior_simulation/#advanced-human-behavior-simulation-framework","title":"Advanced Human Behavior Simulation Framework\u00b6","text":""},{"location":"tutorial/lessons/human_behavior_simulation/#decisions","title":"Decisions\u00b6","text":""},{"location":"tutorial/lessons/human_behavior_simulation/#preception","title":"Preception\u00b6","text":""},{"location":"tutorial/lessons/human_behavior_simulation/#decision-making-responses","title":"Decision making (Responses)\u00b6","text":""},{"location":"tutorial/lessons/organize_model_structure/","title":"Organize your model structure","text":"<p>This tutorial aims at showing the basic logic for organizing models, for maximizing <code>ABSESpy</code>'s ability to allow loose coupling of multiple modules.</p> <p>For building your own model, three main components are necessary to be included:</p> <ul> <li><code>MainModel</code>: stores several parameters and global variables.</li> <li><code>BaseHuman</code>: This module focuses on the human aspect of SES, offering insights and simulations related to human behavior, decisions, and interactions.</li> <li><code>BaseNature</code>: As the name suggests, this module is all about the natural environments, allowing for simulations and analyses of different ecological components.</li> </ul> In\u00a0[1]: Copied! <pre>from abses import MainModel, BaseNature, BaseHuman\n\n# without including any parameters, you can init a MainModel\ntest1 = MainModel()\n</pre> from abses import MainModel, BaseNature, BaseHuman  # without including any parameters, you can init a MainModel test1 = MainModel() <p>By default, create a <code>MainModel</code> instance without parameters is possible. However, in a practical case, it requires three optional parameters:</p> <ul> <li><code>parameters</code>: All parameters that should be used in the simulation of model.</li> <li><code>nature_class</code>: The base module of the nature subsystem.</li> <li><code>human_class</code>: The base module of the human subsystem.</li> </ul> <p>When create an instance of <code>MainModel</code>, you also create two instances: <code>BaseNature</code> and <code>BaseHuman</code> and store them as <code>nature</code> and <code>human</code> properties of model.</p> In\u00a0[2]: Copied! <pre>from omegaconf import dictconfig\n\n# We can pass some parameters.\nparameters = {\"time\": {\"start\": \"2000\", \"freq\": \"Y\"}}\n\n# instance `MainModel`\nmodel = MainModel(parameters=parameters)\n\n# All the primary components have a same property `state`.\nprint(model.state)\nprint(model.human.state)\nprint(model.nature.state)\n</pre> from omegaconf import dictconfig  # We can pass some parameters. parameters = {\"time\": {\"start\": \"2000\", \"freq\": \"Y\"}}  # instance `MainModel` model = MainModel(parameters=parameters)  # All the primary components have a same property `state`. print(model.state) print(model.human.state) print(model.nature.state) <pre>init\ninit\ninit\n</pre> <p>The property <code>state</code> is accessible in <code>model</code>, <code>human</code>, and <code>nature</code> for showing the current state of simulation. In the above code, all of the states are \"init\", which means just being instanced without any other operation. More information about modeling flow can be accessible in tutorial of modeling flow.</p> <p>When <code>state = 'init'</code>, it means a default function <code>.initialize()</code> of <code>BaseHuman</code> and <code>BaseNature</code> have been called. When designing a custom model, it's a great way to setup some prerequisites, like loading data...</p> In\u00a0[3]: Copied! <pre># Including more parameters.\nparameters_2 = parameters | {\n    \"human\": {\"test_human\": 1},\n    \"nature\": {\"test_nature\": \"I'm a parameter!\"},\n}\n\n\n# subclass of `BaseNature`\nclass Nature(BaseNature):\n    def initialize(self):\n        print(\"Init natural module.\")\n\n\n# subclass of `BaseHuman`\nclass Human(BaseHuman):\n    def initialize(self):\n        print(\"Init human module.\")\n\n\n# creating an instance\nmodel = MainModel(\n    parameters=parameters_2, nature_class=Nature, human_class=Human\n)\n</pre> # Including more parameters. parameters_2 = parameters | {     \"human\": {\"test_human\": 1},     \"nature\": {\"test_nature\": \"I'm a parameter!\"}, }   # subclass of `BaseNature` class Nature(BaseNature):     def initialize(self):         print(\"Init natural module.\")   # subclass of `BaseHuman` class Human(BaseHuman):     def initialize(self):         print(\"Init human module.\")   # creating an instance model = MainModel(     parameters=parameters_2, nature_class=Nature, human_class=Human ) <pre>Init natural module.\nInit human module.\n</pre> <p>In the above codes, by subclassing from <code>BaseHuman</code> and <code>BaseNature</code>, we initialize the model by inputing a custom <code>Human</code> module and <code>Nature</code> module. As inputs of initializing a <code>MainModel</code> instance, their custom function <code>.initialize()</code> were called once, seperately. It means, obviously, the custom classes replaced default <code>BaseNature</code> and <code>BaseHuman</code>. We can also find this fact through accessing the corresponding parameters of them:</p> In\u00a0[4]: Copied! <pre># withdraw the parameter from the human module.\nmodel.human.params.test_human\n</pre> # withdraw the parameter from the human module. model.human.params.test_human Out[4]: <pre>1</pre> In\u00a0[5]: Copied! <pre># withdraw the parameter from the nature module.\nmodel.nature.params.test_nature\n</pre> # withdraw the parameter from the nature module. model.nature.params.test_nature Out[5]: <pre>\"I'm a parameter!\"</pre> <p>For better parameters managment, we have another tutorial of control parameters to demonstrate in detail. So far, what you have to know is that the custom <code>Nature</code> and <code>Human</code> modules can access the parameters input into the model because they mock a structure of parameters like this:</p> <pre>time:\n    start: '2000'  # start simulation since 2000.\n    end: '2005'  # The simulation won't be end until 2005.\n    freq: 'M'  # Each counting tick means 1 month in the real world.\n\nhuman:\n    test_human: 1\n\nnature:\n    test_nature: \"I'm a parameter!\"\n</pre> <p>Each class of the model components has a specific name, i.e., here they are <code>human</code> and <code>nature</code>. The corresponding modules would search the parameters structure of model, then withdraw a specific parameter when necessary. In the next sections, you will find this rule will still be applied for sub-modules and actors (agents).</p> <p>Since a social-ecological system is a typical complex system, our users may find their model will growth super big when simulating a real-world case. Therefore, it would be super useful to split the whole model into several logical functional chunks. Different from the two base modules <code>BaseNature</code> and <code>BaseHuman</code>, submodules should be a subclass of <code>HumanModule</code> or <code>PatchModule</code>.</p> In\u00a0[6]: Copied! <pre>from abses.human import HumanModule\n\n\nclass Society(HumanModule):\n    \"\"\"How agent behaves in a society.\"\"\"\n\n\nclass Economy(HumanModule):\n    \"\"\"Some logics in a economic sub-system.\"\"\"\n\n\n# create the submodule by `create_module` function.\nsociety = model.human.create_module(Society)\neconomy = model.human.create_module(Economy, name=\"economy\")\n\n# added two submodules to the human module.\nmodel.human.modules\n</pre> from abses.human import HumanModule   class Society(HumanModule):     \"\"\"How agent behaves in a society.\"\"\"   class Economy(HumanModule):     \"\"\"Some logics in a economic sub-system.\"\"\"   # create the submodule by `create_module` function. society = model.human.create_module(Society) economy = model.human.create_module(Economy, name=\"economy\")  # added two submodules to the human module. model.human.modules Out[6]: <pre>[&lt;society: open&gt;, &lt;economy: open&gt;]</pre> In\u00a0[7]: Copied! <pre>economy.name\n</pre> economy.name Out[7]: <pre>'economy'</pre> <p>Since we assigned the name of sub-module <code>Economy</code>, of cause its name is \"economy\". At the same time, if we don't assign the name of submodule, it's name will be lowercase <code>__class__.__name__</code>. Therefore, module name of <code>Society</code> should be 'society'. The module names are very important for searching the corresponding parameters.</p> In\u00a0[8]: Copied! <pre>society.name\n</pre> society.name Out[8]: <pre>'society'</pre> <p>Submodules don't have property of 'state'. In stead, they can be turned off or turned on. By default, a new module will be opened, we can turn it off in some cases.</p> In\u00a0[9]: Copied! <pre>print(society.opening)\n\n# turn it off\nsociety.switch_open_to(False)\nprint(society.opening)\n</pre> print(society.opening)  # turn it off society.switch_open_to(False) print(society.opening) <pre>2023-11-21 12:10:17.384 | INFO     | abses.modules:switch_open_to:47 - %s switch 'open' to %s.\n</pre> <pre>True\nFalse\n</pre> <p>There are two properties in a model:</p> <ul> <li><code>agents</code>: A container of all agents in the model.</li> <li><code>glob_vars</code>: A list of all global parameters, which can be accesiible by all components and actors (agents).</li> </ul> <p><code>agents</code> is a unique signleton instance of <code>AgentsContainer</code> for a specific model where all agents are stored. You can operate the agents here by refering this agents operation tutorial. Now, let us try to create some agents for showing how the global variables work.</p> In\u00a0[10]: Copied! <pre>model.glob_vars\n</pre> model.glob_vars Out[10]: <pre>[]</pre> In\u00a0[11]: Copied! <pre>model.agents\n</pre> model.agents Out[11]: <pre>&lt;AgentsContainer: &gt;</pre> In\u00a0[12]: Copied! <pre>from abses import Actor\n\nactors = model.agents.create(Actor, 3)\n\n# Now the container has three actors.\nmodel.agents\n</pre> from abses import Actor  actors = model.agents.create(Actor, 3)  # Now the container has three actors. model.agents Out[12]: <pre>&lt;AgentsContainer: (3)Actor&gt;</pre> In\u00a0[13]: Copied! <pre>model.test_glob = \"I'm a global variable!\"\n\nmodel.add_glob_vars(\"test_glob\")\n\n# let us choose an agent randomly.\nagent = model.agents.to_list().random_choose()\n\nagent.test_glob\n</pre> model.test_glob = \"I'm a global variable!\"  model.add_glob_vars(\"test_glob\")  # let us choose an agent randomly. agent = model.agents.to_list().random_choose()  agent.test_glob Out[13]: <pre>\"I'm a global variable!\"</pre> <p>Since they are variable, they may be changed sometimes and you need notify any change to the observers.</p> In\u00a0[14]: Copied! <pre># change a variable and notify all the observers.\nmodel.test_glob = \"variable is ... variable, change it if you want.\"\n\n# notify any change to the observers.\nmodel.notify()\n\nagent.test_glob\n</pre> # change a variable and notify all the observers. model.test_glob = \"variable is ... variable, change it if you want.\"  # notify any change to the observers. model.notify()  agent.test_glob Out[14]: <pre>'variable is ... variable, change it if you want.'</pre> <p>And since it's called a global variable, it's not just the actors can access them, but also the components (modules and sub-modules).</p> In\u00a0[15]: Copied! <pre># Module can access the global variable\nmodel.nature.test_glob\n</pre> # Module can access the global variable model.nature.test_glob Out[15]: <pre>'variable is ... variable, change it if you want.'</pre> In\u00a0[16]: Copied! <pre># sub module can also access the global variables.\nmodel.human.society.test_glob\n</pre> # sub module can also access the global variables. model.human.society.test_glob Out[16]: <pre>'variable is ... variable, change it if you want.'</pre>"},{"location":"tutorial/lessons/organize_model_structure/#organize-your-model-structure","title":"Organize your model structure\u00b6","text":""},{"location":"tutorial/lessons/organize_model_structure/#main-components","title":"Main components\u00b6","text":""},{"location":"tutorial/lessons/organize_model_structure/#create-extensible-sub-modules","title":"Create extensible sub-modules\u00b6","text":""},{"location":"tutorial/lessons/organize_model_structure/#global-variable-and-its-observers","title":"Global variable and its observers\u00b6","text":""},{"location":"tutorial/lessons/time_control/","title":"Real-world SES modeling enhancements","text":"<p>In Socio-Ecological Systems (SES) modeling, a real-world event's natural or human-induced duration can range from seconds to centuries. Recognizing the importance of time in modeling real-world problems, ABSESpy introduces a superior time control mechanism that stands out from traditional agent-based modeling frameworks.</p> <p>The same as traditional agent-based modeling framework and, by default, <code>ABSESpy</code> records each simulating step as an increment of counting ticker.</p> In\u00a0[1]: Copied! <pre>from IPython.core.interactiveshell import InteractiveShell\n\nInteractiveShell.ast_node_interactivity = \"all\"\n\nfrom abses import MainModel\n\n# create a tick mode model.\nmodel = MainModel()\n\nmodel.time.ticking_mode\n</pre> from IPython.core.interactiveshell import InteractiveShell  InteractiveShell.ast_node_interactivity = \"all\"  from abses import MainModel  # create a tick mode model. model = MainModel()  model.time.ticking_mode Out[1]: <pre>'tick'</pre> <p><code>TimeDriver</code> is the major class where most time-related functions are implementationed. For detailed usage, please check out the API documentation.</p> <p>Under this simplest and most-popular mode, let's try to go 5 steps. Notice that <code>tick</code> of time went from <code>0</code> to <code>5</code>.</p> In\u00a0[2]: Copied! <pre>model.time\n\nmodel.time.go(5)\n\n# Counter\nmodel.time\n</pre> model.time  model.time.go(5)  # Counter model.time Out[2]: <pre>&lt;TimeDriver: tick[0]&gt;</pre> Out[2]: <pre>&lt;TimeDriver: tick[5]&gt;</pre> <p>Another important property of <code>TimeDriver</code>, the <code>start_dt</code> stores when the <code>TimeDriver</code> was run firstly under the 'tick' mode.</p> In\u00a0[3]: Copied! <pre>model.time.start_dt\n</pre> model.time.start_dt Out[3]: <pre>DateTime(2023, 11, 21, 12, 10, 31, 840232)</pre> <p>However, by introducing a feature what we named as a Duration Mode, <code>ABSESpy</code> makes much easier to simulate the actual progression of time. Bellow is a simple implementation of yearly-step model:</p> In\u00a0[4]: Copied! <pre>parameters = {\n    \"time\": {\n        \"years\": 1,\n    }\n}\n\nmodel = MainModel(parameters=parameters)\n\n# Another ticking model.\nmodel.time.ticking_mode\n</pre> parameters = {     \"time\": {         \"years\": 1,     } }  model = MainModel(parameters=parameters)  # Another ticking model. model.time.ticking_mode Out[4]: <pre>'duration'</pre> <p>By introducing a param of <code>years = 1</code> under the 'time' session, our model ticking-mode changed to 'duration'. Which means whenever the model goes a step, the simulation is like one year of real-world time.</p> In\u00a0[5]: Copied! <pre>model.time\n\n# go six years... ...\nmodel.time.go(6)\n\nmodel.time\n</pre> model.time  # go six years... ... model.time.go(6)  model.time Out[5]: <pre>&lt;TimeDriver: 2023-11-21 12:10:31&gt;</pre> Out[5]: <pre>&lt;TimeDriver: 2029-11-21 12:10:31&gt;</pre> <p>As you could see, the real-time counted from a start of the current time, we can change the behaviors by inputing different parameters of 'time' session. See this parameters management tutorial to learn how to make full use of this feature. Bellow is the possible parameters table:</p> <p><code>TimeDriver</code> accepts below parameters:</p> Parameter Name Expected Data Type Default Value Description start str, None None If None: use the current time, else: should be a string which can be parsed by <code>pendulum.parse()</code>. end str, int, None None If it's a string that can be parsed into datetime the model should end until achieving this time; if int: the model should end in that tick; if None no auto-end. irregular bool False If False: not dive into an irregular mode (tick-mode); if True, the model will solve as an irregular mode. years int 0 Time duration in years for the duration mode. months int 0 Time duration in months for the duration mode. weeks int 0 Time duration in weeks for the duration mode. days int 0 Time duration in days for the duration mode. hours int 0 Time duration in hours for the duration mode. minutes int 0 Time duration in minutes for the duration mode. seconds int 0 Time duration in seconds for the duration mode. <p>This is a highly customisable mode, but accordingly, it is not commonly used and requires more code to be written by the user, so it is only briefly described here. To enable this mode, make sure that the <code>record</code> parameter of the time module is turned on, and that there can't be any parameters that trigger the <code>duration</code> mode (e.g. <code>years</code>, <code>months</code>, <code>days</code>, <code>hours</code>, <code>minutes</code> and <code>seconds</code>)</p> In\u00a0[6]: Copied! <pre>parameters = {\n    \"time\": {\"irregular\": True, \"start\": \"2020-01-01\", \"end\": \"2022-01-01\"}\n}\n\nmodel = MainModel(parameters=parameters)\nmodel.time.go(years=1)\nmodel.time.go(ticks=0, months=5)\nmodel.time.go(ticks=3, days=100)\n</pre> parameters = {     \"time\": {\"irregular\": True, \"start\": \"2020-01-01\", \"end\": \"2022-01-01\"} }  model = MainModel(parameters=parameters) model.time.go(years=1) model.time.go(ticks=0, months=5) model.time.go(ticks=3, days=100) In\u00a0[7]: Copied! <pre>model.time\nmodel.time.end_dt\n\nmodel.time.should_end\n</pre> model.time model.time.end_dt  model.time.should_end Out[7]: <pre>&lt;TimeDriver: irregular[4] 2022-03-28 00:00:00&gt;</pre> Out[7]: <pre>DateTime(2022, 1, 1, 0, 0, 0)</pre> Out[7]: <pre>True</pre> <p>Of the most important reasons to use real-world data and time is dynamically loading and updating time-series datasets.</p> <p>For testing this feature, let's create a time-series data by pandas.</p> In\u00a0[8]: Copied! <pre>import pandas as pd\n\ndt_index = pd.date_range(\"2000-01-01\", \"2020-01-01\", freq=\"Y\")\ndata_1 = pd.Series(data=range(len(dt_index)), index=dt_index.year)\n\ndata_1\n</pre> import pandas as pd  dt_index = pd.date_range(\"2000-01-01\", \"2020-01-01\", freq=\"Y\") data_1 = pd.Series(data=range(len(dt_index)), index=dt_index.year)  data_1 Out[8]: <pre>2000     0\n2001     1\n2002     2\n2003     3\n2004     4\n2005     5\n2006     6\n2007     7\n2008     8\n2009     9\n2010    10\n2011    11\n2012    12\n2013    13\n2014    14\n2015    15\n2016    16\n2017    17\n2018    18\n2019    19\ndtype: int64</pre> <p>For selecting the data from a corresponding year dynamically, we need to define a <code>_DynamicVariable</code>. In the belowing testing model</p> In\u00a0[9]: Copied! <pre>parameters = {\n    \"time\": {\n        \"start\": \"2000-12-31\",\n        \"years\": 5,  # Notice this, each step corresponds to 5 real-world years.\n    }\n}\n\n# setup a testing model.\nmodel = MainModel(parameters=parameters)\n\n\n# define a function to solve the data_1.\ndef withdraw_data(data, time):\n    \"\"\"Function for dynamic data withdraw\"\"\"\n    return data.loc[time.year]\n\n\n# define the dyanamic data, storing `withdrawing function` and the `data source`.\nmodel.human.add_dynamic_variable(\n    name=\"data_1\", data=data_1, function=withdraw_data\n)\n</pre> parameters = {     \"time\": {         \"start\": \"2000-12-31\",         \"years\": 5,  # Notice this, each step corresponds to 5 real-world years.     } }  # setup a testing model. model = MainModel(parameters=parameters)   # define a function to solve the data_1. def withdraw_data(data, time):     \"\"\"Function for dynamic data withdraw\"\"\"     return data.loc[time.year]   # define the dyanamic data, storing `withdrawing function` and the `data source`. model.human.add_dynamic_variable(     name=\"data_1\", data=data_1, function=withdraw_data ) <p>Since we store a time-series data withdrawing rule, we can access the data dyanamically in the future whenever the time goes by.</p> In\u00a0[10]: Copied! <pre>model.human.dynamic_var(\"data_1\")\n</pre> model.human.dynamic_var(\"data_1\") Out[10]: <pre>0</pre> <p>Next selection should be 5 (because the real-world time goes 5 years per step).</p> In\u00a0[11]: Copied! <pre>model.time.go()\nmodel.human.dynamic_var(\"data_1\")\n</pre> model.time.go() model.human.dynamic_var(\"data_1\") Out[11]: <pre>5</pre> <p>Then, 10... and so on</p> In\u00a0[12]: Copied! <pre># should be 10\nmodel.time.go()\nmodel.human.dynamic_var(\"data_1\")\n\n# should be 15\nmodel.time.go()\nmodel.human.dynamic_var(\"data_1\")\n</pre> # should be 10 model.time.go() model.human.dynamic_var(\"data_1\")  # should be 15 model.time.go() model.human.dynamic_var(\"data_1\") Out[12]: <pre>10</pre> Out[12]: <pre>15</pre> <p>Dynamic data may be beneficial because modeling the real-world SES problem often requires various datasets as inputs. You won't want to re-calculate the data in each step... So! Just define them as dynamic variables when initializing or setting up a module by uploading a <code>withdraw data function</code> and a <code>data source</code>. It should also be applied to spatial datasets! Like selecting a raster data through some withdrawing function like <code>xarray.DataArray.sel(time=...)</code>.</p> <p>Triggering some function based on a specific condition is another advanced application and highlight advantage of using real-world time. In <code>ABSESpy</code> we provide a decorator named <code>time_condition</code> to do so. The below use case is intuitive: our custom <code>Actor</code> class <code>TestActor</code> has a function but we only want to use it on the day of the beginning of a year. Therefore, we define a condition dictionary <code>{'month': 1, 'day': 1}</code>. Therefore, in the 10 times run, the function is called only once.</p> In\u00a0[13]: Copied! <pre>from abses.time import time_condition\nfrom abses import Actor\n\n\nclass TestActor(Actor):\n    @time_condition(condition={\"month\": 1, \"day\": 1}, when_run=True)\n    def happy_new_year(self):\n        print(\"Today is 1th, January, Happy new year!\")\n\n\nparameters = {\"time\": {\"start\": \"1996-12-24\", \"days\": 1}}\n\n\nmodel = MainModel(parameters=parameters)\nagent = model.agents.create(TestActor, 1, singleton=True)\n\nfor _ in range(10):\n    print(f\"Time now is {model.time}\")\n    model.time.go()\n    agent.happy_new_year()\n</pre> from abses.time import time_condition from abses import Actor   class TestActor(Actor):     @time_condition(condition={\"month\": 1, \"day\": 1}, when_run=True)     def happy_new_year(self):         print(\"Today is 1th, January, Happy new year!\")   parameters = {\"time\": {\"start\": \"1996-12-24\", \"days\": 1}}   model = MainModel(parameters=parameters) agent = model.agents.create(TestActor, 1, singleton=True)  for _ in range(10):     print(f\"Time now is {model.time}\")     model.time.go()     agent.happy_new_year() <pre>Time now is &lt;TimeDriver: 1996-12-24 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-25 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-26 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-27 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-28 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-29 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-30 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-31 00:00:00&gt;\nToday is 1th, January, Happy new year!\nTime now is &lt;TimeDriver: 1997-01-01 00:00:00&gt;\nTime now is &lt;TimeDriver: 1997-01-02 00:00:00&gt;\n</pre> <p>It should be called again in the next year beginning (i.e., <code>1998-01-01</code>) if we run this model longer... It means, the function will be called when the condition is fully satisfied. However, we can setup an opposite case by setting parameter <code>when_run = False</code>:</p> In\u00a0[14]: Copied! <pre>class TestActor_2(Actor):\n    @time_condition(condition={\"month\": 1, \"day\": 6}, when_run=False)\n    def working(self):\n        print(\"I have to work today \ud83d\ude2d!\")\n\n\nagent_2 = model.agents.create(TestActor_2, 1, singleton=True)\nfor _ in range(5):\n    print(f\"Time now is {model.time}\")\n    model.time.go()\n    agent_2.working()\n</pre> class TestActor_2(Actor):     @time_condition(condition={\"month\": 1, \"day\": 6}, when_run=False)     def working(self):         print(\"I have to work today \ud83d\ude2d!\")   agent_2 = model.agents.create(TestActor_2, 1, singleton=True) for _ in range(5):     print(f\"Time now is {model.time}\")     model.time.go()     agent_2.working() <pre>Time now is &lt;TimeDriver: 1997-01-03 00:00:00&gt;\nI have to work today \ud83d\ude2d!\nTime now is &lt;TimeDriver: 1997-01-04 00:00:00&gt;\nI have to work today \ud83d\ude2d!\nTime now is &lt;TimeDriver: 1997-01-05 00:00:00&gt;\nTime now is &lt;TimeDriver: 1997-01-06 00:00:00&gt;\nI have to work today \ud83d\ude2d!\nTime now is &lt;TimeDriver: 1997-01-07 00:00:00&gt;\nI have to work today \ud83d\ude2d!\n</pre> <p>In the above case, the <code>agent_2</code> didn't have to work on 6th, January (as we set in the condition dictionary) \ud83d\ude04!</p> <p>This ensures that certain actions or events only occur at the right moments in your simulation, mirroring real-world occurrences with higher fidelity.</p>"},{"location":"tutorial/lessons/time_control/#real-world-ses-modeling-enhancements","title":"Real-world SES modeling enhancements\u00b6","text":""},{"location":"tutorial/lessons/time_control/#real-world-time-configurations","title":"Real-world time configurations\u00b6","text":""},{"location":"tutorial/lessons/time_control/#tick-mode","title":"'Tick' mode\u00b6","text":""},{"location":"tutorial/lessons/time_control/#duration-mode","title":"'duration' mode\u00b6","text":""},{"location":"tutorial/lessons/time_control/#irregular-mode","title":"'Irregular' mode\u00b6","text":""},{"location":"tutorial/lessons/time_control/#auto-update-dynamic-variables","title":"Auto-update Dynamic Variables\u00b6","text":""},{"location":"tutorial/lessons/time_control/#conditional-time-based-triggering","title":"Conditional Time-based Triggering\u00b6","text":""},{"location":"tutorial/notebooks/human/CCR_example/","title":"Apply CCR framework","text":"<p>This is an example for applying the Cognition, Contagion and behavioral Response (CCR Framework) with <code>ABSESpy</code>. This framework consisted by three parts:</p> <ul> <li>Cognition represents the human processing of information around the ecological system.</li> <li>Contagion represents spreading information, beliefs and behaviour through social networks.</li> <li>Response is the resultant behaviour or action.</li> </ul> <p>To apply this cognition-contagion-response (CCR) human behaviour modelling framework, <code>ABSESpy</code>'s users can:</p> <ol> <li>define cognition functions for actors (agents);</li> <li>generate a network in human modules;</li> <li>in a human model, define action arena functions of actors' interactions or responses.</li> </ol> <p>As an example, we demonstrate an adapted simple but classic Agent-based model of <code>Wealth Transferring</code>. Other popular Agent-based modelling software (e.g., <code>NetLogo</code>) or packages (<code>AgentPy</code> and <code>MESA</code>) both include this model in their model libraries.</p> <p>The model explores the distribution of wealth under a trading population of agents. Each agent starts with one unit of wealth. During each time-step, each agents with positive wealth randomly selects a trading partner and gives them one unit of their wealth. We will see that this random interaction will create an inequality of wealth that follows a Boltzmann distribution.</p> <p>Here we will rewrite the model in the framework of CCR and add geographical distance as a parameter to the classical model. It is shown how actors perceive other actors, how behaviors \"spreads\" between actors and how \"transaction scenarios\" are automatically formed between actors.</p> In\u00a0[\u00a0]: Copied! <pre>from abses import Actor\nfrom typing import Optional, Self\n\nfrom abses.main import MainModel\n\n\nclass WealthyActor(Actor):\n\n    \"\"\"Demo model of wealth transferring.\"\"\"\n\n    def __init__(\n        self,\n        model: MainModel,\n        observer: bool = True,\n        unique_id: int | None = None,\n        **kwargs\n    ) -&gt; None:\n        super().__init__(model, observer, unique_id, **kwargs)\n\n    def setup(self):\n        self.wealth = 1\n\n    def wealth_transfer(self, partner: Optional[Self] = None):\n        if partner is None:\n            partner = self.model.all_agents.random_choose()\n        if self.wealth &gt; 0:\n            partner.wealth += 1\n            self.wealth -= 1\n</pre> from abses import Actor from typing import Optional, Self  from abses.main import MainModel   class WealthyActor(Actor):      \"\"\"Demo model of wealth transferring.\"\"\"      def __init__(         self,         model: MainModel,         observer: bool = True,         unique_id: int | None = None,         **kwargs     ) -&gt; None:         super().__init__(model, observer, unique_id, **kwargs)      def setup(self):         self.wealth = 1      def wealth_transfer(self, partner: Optional[Self] = None):         if partner is None:             partner = self.model.all_agents.random_choose()         if self.wealth &gt; 0:             partner.wealth += 1             self.wealth -= 1 <p>Then, define the metrics (Gini coefficient) and model workflow.</p> In\u00a0[\u00a0]: Copied! <pre>from abses import MainModel\nimport numpy as np\n\n\ndef gini(x):\n    \"\"\"Calculate Gini Coefficient\"\"\"\n    # By Warren Weckesser https://stackoverflow.com/a/39513799\n\n    x = np.array(x)\n    mad = np.abs(np.subtract.outer(x, x)).mean()  # Mean absolute difference\n    rmad = mad / np.mean(x)  # Relative mean absolute difference\n    return 0.5 * rmad\n\n\nclass WealthModel(MainModel):\n\n    \"\"\"A simple model of random wealth transfers\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def setup(self):\n        actors = self.agents.create(WealthyActor, 100)\n\n    def step(self):\n        self.agents.wealth_transfer()\n\n    def update(self):\n        self.record(\"Gini Coefficient\", gini(self.all_agents.wealth))\n\n    def end(self):\n        self.all_agents.record(\"wealth\")\n</pre> from abses import MainModel import numpy as np   def gini(x):     \"\"\"Calculate Gini Coefficient\"\"\"     # By Warren Weckesser https://stackoverflow.com/a/39513799      x = np.array(x)     mad = np.abs(np.subtract.outer(x, x)).mean()  # Mean absolute difference     rmad = mad / np.mean(x)  # Relative mean absolute difference     return 0.5 * rmad   class WealthModel(MainModel):      \"\"\"A simple model of random wealth transfers\"\"\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)      def setup(self):         actors = self.agents.create(WealthyActor, 100)      def step(self):         self.agents.wealth_transfer()      def update(self):         self.record(\"Gini Coefficient\", gini(self.all_agents.wealth))      def end(self):         self.all_agents.record(\"wealth\") <p>Input parameters to the model, and show Gini coefficient results.</p> In\u00a0[\u00a0]: Copied! <pre>parameters = {\n    \"wealth demo\": {\n        \"agents\": 100,\n        \"steps\": 100,\n        \"seed\": 42,\n    }\n}\n\nmodel = WealthModel(name=\"wealth demo\", base=\"tests\", parameters=parameters)\nresults = model.run_model()\n</pre> parameters = {     \"wealth demo\": {         \"agents\": 100,         \"steps\": 100,         \"seed\": 42,     } }  model = WealthModel(name=\"wealth demo\", base=\"tests\", parameters=parameters) results = model.run_model() In\u00a0[\u00a0]: Copied! <pre>%pip install seaborn\n\nimport seaborn as sns\n\nsns.histplot(data=results.variables.WealthyActor, binwidth=1);\n</pre> %pip install seaborn  import seaborn as sns  sns.histplot(data=results.variables.WealthyActor, binwidth=1); <ol> <li>An actor can only trade with nearby actors (with a parameter of distance 'd').</li> <li>If actor feel his community is not aproprate for his economic class, he will move randomly.</li> <li>If actors have the similar properties within the community, he likes to trade with neighbors.</li> </ol> <p></p> In\u00a0[\u00a0]: Copied! <pre>from abses.actor import perception, link_to, check_rule\n\n\nclass WealthyActor(Actor):\n\n    \"\"\"Demo model of wealth transferring.\"\"\"\n\n    def setup(self):\n        self.wealth: int = 1\n        # define a rule: when this actor is not fit-in, then move randomly.\n        self.rule(\n            when=\"fit_in == False\",\n            then=\"move\",\n            check_now=False,\n            frequency=\"now\",\n        )\n\n    # setup property 'potential partner',\n    # which auto links to these potential partners.\n    @link_to\n    def potential_partners(self):\n        return self.neighbors(distance=5)\n\n    # perception makes this method as property\n    @perception\n    def fit_in(self) -&gt; bool:\n        if len(self.potential_partners) == 0:\n            return False\n        else:\n            return True\n\n    # decorator `check_rule` means check all rules before running this function.\n    # parameter `loop = True` means, unless no rule is triggered, the method not be executed\n    @check_rule(loop=True)\n    def wealth_transfer(self):\n        partner = self.potential_partners.random_choose()\n        if self.wealth &gt; 0:\n            partner.wealth += 1\n            self.wealth -= 1\n\n\nclass WealthModel(MainModel):\n\n    \"\"\"A simple model of random wealth transfers\"\"\"\n\n    def setup(self):\n        actors = self.agents.create(WealthyActor, 100)\n        self.nature.add_agents(actors, replace=True)\n\n    def step(self):\n        self.all_agents.wealth_transfer()\n\n    def update(self):\n        self.record(\"Gini Coefficient\", gini(self.all_agents.wealth))\n\n    def end(self):\n        self.all_agents.record(\"wealth\")\n</pre> from abses.actor import perception, link_to, check_rule   class WealthyActor(Actor):      \"\"\"Demo model of wealth transferring.\"\"\"      def setup(self):         self.wealth: int = 1         # define a rule: when this actor is not fit-in, then move randomly.         self.rule(             when=\"fit_in == False\",             then=\"move\",             check_now=False,             frequency=\"now\",         )      # setup property 'potential partner',     # which auto links to these potential partners.     @link_to     def potential_partners(self):         return self.neighbors(distance=5)      # perception makes this method as property     @perception     def fit_in(self) -&gt; bool:         if len(self.potential_partners) == 0:             return False         else:             return True      # decorator `check_rule` means check all rules before running this function.     # parameter `loop = True` means, unless no rule is triggered, the method not be executed     @check_rule(loop=True)     def wealth_transfer(self):         partner = self.potential_partners.random_choose()         if self.wealth &gt; 0:             partner.wealth += 1             self.wealth -= 1   class WealthModel(MainModel):      \"\"\"A simple model of random wealth transfers\"\"\"      def setup(self):         actors = self.agents.create(WealthyActor, 100)         self.nature.add_agents(actors, replace=True)      def step(self):         self.all_agents.wealth_transfer()      def update(self):         self.record(\"Gini Coefficient\", gini(self.all_agents.wealth))      def end(self):         self.all_agents.record(\"wealth\") <p>In the above adaptation:</p> <ol> <li>Each actor defines a cognition according to the surrounding situation (<code>@perception</code>) -- <code>fit-in</code>.</li> <li>Each actor has an attribute of some potential partners, because of <code>@link_to</code> decorator. If social influences exist (contagion), user can define their interaction between <code>Actor</code> and <code>Actor.potential_partners</code>.</li> <li>Wealth transfer between actors are the actions of Response. Here we applied a much more complex rule: only some situation of an actor are satisfied (by adding <code>@check_rule</code> decorator), the response then triggered... Using this in modeling will be closer to real human decision-making behavior.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>parameters = {\n    \"wealth demo\": {\n        \"agents\": 100,\n        \"steps\": 100,\n        \"seed\": 42,\n    }\n}\n\nmodel = WealthModel(name=\"wealth demo\", base=\"tests\", parameters=parameters)\nresults = model.run()\n</pre> parameters = {     \"wealth demo\": {         \"agents\": 100,         \"steps\": 100,         \"seed\": 42,     } }  model = WealthModel(name=\"wealth demo\", base=\"tests\", parameters=parameters) results = model.run() In\u00a0[\u00a0]: Copied! <pre>sns.histplot(data=results.variables.WealthyActor, binwidth=1);\n</pre> sns.histplot(data=results.variables.WealthyActor, binwidth=1);"},{"location":"tutorial/notebooks/human/CCR_example/#apply-ccr-framework","title":"Apply CCR framework\u00b6","text":""},{"location":"tutorial/notebooks/human/CCR_example/#example-model","title":"Example model\u00b6","text":""},{"location":"tutorial/notebooks/human/CCR_example/#original-model-framework","title":"Original Model Framework\u00b6","text":"<p>Referring codes from the <code>AgentPy</code> package</p> <p>Frist of all, define the actors' behaviour.</p>"},{"location":"tutorial/notebooks/human/CCR_example/#adapted-wealth-transferring-problem","title":"Adapted wealth transferring problem\u00b6","text":""},{"location":"tutorial/notebooks/human/actors/","title":"Actors' operation","text":"In\u00a0[\u00a0]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport os\n\nos.chdir(\"../..\")\n</pre> %load_ext autoreload %autoreload 2  import os  os.chdir(\"../..\") In\u00a0[\u00a0]: Copied! <pre>from abses import Actor, MainModel\n\n# create a testing model\nmodel = MainModel(name=\"actor_example\", base=\"tests\")\n\n# actor creation should be bounded with a model.\nactor = Actor(model)\n\n# actor has a class-property, -its breed, class's name.\nactor.breed  # same as `actor.__class__.__name__`\n</pre> from abses import Actor, MainModel  # create a testing model model = MainModel(name=\"actor_example\", base=\"tests\")  # actor creation should be bounded with a model. actor = Actor(model)  # actor has a class-property, -its breed, class's name. actor.breed  # same as `actor.__class__.__name__` In\u00a0[\u00a0]: Copied! <pre># In an initial condition, this actor is not on the earth...\nactor.on_earth\n</pre> # In an initial condition, this actor is not on the earth... actor.on_earth In\u00a0[\u00a0]: Copied! <pre># however, we can let it settle down on a specific position of the earth.\npos = (4, 4)\nsettled = actor.move_to(position=pos)\n\nactor.pos  # position of the actor now: (4, 4)\nactor.on_earth  # True\n</pre> # however, we can let it settle down on a specific position of the earth. pos = (4, 4) settled = actor.move_to(position=pos)  actor.pos  # position of the actor now: (4, 4) actor.on_earth  # True <p>Note that <code>Actor</code>s created in this way is not accessible from the model, unless we add it into the model.</p> In\u00a0[\u00a0]: Copied! <pre>actor in model.agents  # False\n\n# `register` must be assigned with True, because it's a new breed for this model.\nmodel.agents.add(actor, register=True)\n\nactor in model.agents  # True\n</pre> actor in model.agents  # False  # `register` must be assigned with True, because it's a new breed for this model. model.agents.add(actor, register=True)  actor in model.agents  # True <p>Actor is an <code>BaseObj</code> of the model, so it inherits all of its properties.</p> In\u00a0[\u00a0]: Copied! <pre># default, it's name is as same as its breed in lower case\nactor.name  # 'Actor'\n\n# if assigned name when creating, they will be different.\nactor2 = Actor(model, name=\"actor2\")\nactor2.breed\nactor2.name\n</pre> # default, it's name is as same as its breed in lower case actor.name  # 'Actor'  # if assigned name when creating, they will be different. actor2 = Actor(model, name=\"actor2\") actor2.breed actor2.name <p>When the model is created, there is a unique <code>AgentsContainer</code> obj bounding. It saves agents by their breeds.</p> In\u00a0[\u00a0]: Copied! <pre>type(model.agents)\nmodel.agents  # only one actor is added now.\n\nmodel.agents.breeds  # breeds\n</pre> type(model.agents) model.agents  # only one actor is added now.  model.agents.breeds  # breeds <p>Container makes creating actors much easier:</p> In\u00a0[\u00a0]: Copied! <pre># define a new breed of actor\nclass Seller(Actor):\n    pass\n\n\nclass User(Actor):\n    pass\n\n\nanother_actor = model.agents.create(Actor)\nseller = model.agents.create(Seller)  # default creating one actor.\nusers = model.agents.create(User, 5)  # creating 5 actors\n\nmodel.agents\n</pre> # define a new breed of actor class Seller(Actor):     pass   class User(Actor):     pass   another_actor = model.agents.create(Actor) seller = model.agents.create(Seller)  # default creating one actor. users = model.agents.create(User, 5)  # creating 5 actors  model.agents <p>While <code>AgentsContainer</code> mainly provides a way to store, most of manipulations for actors are implemented in another data type: <code>ActorsList</code>. <code>AgentsContainer</code> also has many ways to convert existing agents to this data type:</p> In\u00a0[\u00a0]: Copied! <pre># generate all existing agents to an `ActorsList`.\nmodel.agents.to_list()\n</pre> # generate all existing agents to an `ActorsList`. model.agents.to_list() In\u00a0[\u00a0]: Copied! <pre># select specific breeds.\nmodel.agents.to_list(breeds=\"Seller\")\nmodel.agents.to_list(breeds=[\"Seller\", \"User\"])\n</pre> # select specific breeds. model.agents.to_list(breeds=\"Seller\") model.agents.to_list(breeds=[\"Seller\", \"User\"]) In\u00a0[\u00a0]: Copied! <pre># also accessible through attributes.\nmodel.agents.User\n</pre> # also accessible through attributes. model.agents.User In\u00a0[\u00a0]: Copied! <pre>lst = model.agents.to_list()\nactor = lst[0]  # indexing -&gt; an `Actor`\nfive_actors = lst[:5]  # slice -&gt; another `ActorsList` object\n\nfive_actors  # (2)Actor; (1)Seller; (2)User\n# five_actors contains this actor\nactor in five_actors\n</pre> lst = model.agents.to_list() actor = lst[0]  # indexing -&gt; an `Actor` five_actors = lst[:5]  # slice -&gt; another `ActorsList` object  five_actors  # (2)Actor; (1)Seller; (2)User # five_actors contains this actor actor in five_actors <p>Convert the list to a dictionary: <code>{breed: ActorsList}</code></p> In\u00a0[\u00a0]: Copied! <pre># sort up mixed actors.\nfive_actors.to_dict()\n</pre> # sort up mixed actors. five_actors.to_dict() <p>Select by conditions.</p> In\u00a0[\u00a0]: Copied! <pre>five_actors.select(selection=\"User\")  # same as .to_dict()['User']\n\n# select the first and the fourth actors\nfive_actors.select(selection=[True, False, False, True, False])\n</pre> five_actors.select(selection=\"User\")  # same as .to_dict()['User']  # select the first and the fourth actors five_actors.select(selection=[True, False, False, True, False]) <p>Actors' attributes are accessible as <code>np.ndarray</code>.</p> In\u00a0[\u00a0]: Copied! <pre># get each Actor(object)'s id.\nfive_actors.array(\"id\")\n\n# alternative way to get this attribute.\nfive_actors.id\n</pre> # get each Actor(object)'s id. five_actors.array(\"id\")  # alternative way to get this attribute. five_actors.id <p>You can access all actors in this list with <code>id &gt;= 7</code> by:</p> In\u00a0[\u00a0]: Copied! <pre>better_guys = five_actors.better(metric=\"id\", than=7)\nbetter_guys.id\n</pre> better_guys = five_actors.better(metric=\"id\", than=7) better_guys.id <p>Split the list in the second, third places: <code>[1, 2, | 3, | 4, 5]</code></p> In\u00a0[\u00a0]: Copied! <pre>five_actors.split([2, 3])\n</pre> five_actors.split([2, 3])"},{"location":"tutorial/notebooks/human/actors/#actors-operation","title":"Actors' operation\u00b6","text":""},{"location":"tutorial/notebooks/human/actors/#manipulate-an-individual-actor","title":"Manipulate an individual <code>Actor</code>\u00b6","text":""},{"location":"tutorial/notebooks/human/actors/#manipulate-a-group-of-actors","title":"Manipulate a group of <code>Actors</code>\u00b6","text":"<p><code>ABSESpy</code> provides two different container of actors:</p> <ul> <li><code>AgentsContainer</code>: A unique <code>dictionary</code>-like class where all agents of the model are saving.</li> <li><code>ActorsList</code>: A <code>list</code>-like class where referring some actors temporally.</li> </ul>"},{"location":"tutorial/notebooks/human/actors/#agentscontainer","title":"AgentsContainer\u00b6","text":""},{"location":"tutorial/notebooks/human/actors/#actorslist","title":"<code>ActorsList</code>\u00b6","text":"<p><code>ActorsList</code> is a collection of <code>Actors</code>, facilitate to manipulate them at a batch.</p>"},{"location":"tutorial/notebooks/human/movement/","title":"Movement of actors","text":""},{"location":"tutorial/notebooks/human/movement/#movement-of-actors","title":"Movement of actors\u00b6","text":""},{"location":"tutorial/notebooks/human/rules/","title":"Actors manipulation","text":"<p>The core of ABM is the definition of individual behaviour of actors. However, when implementing a program, it is necessary to operate on individuals that satisfy certain conditions. The resulting diversity of actor behaviour is one of the biggest challenges in implementing SES modelling. To this end, <code>ABSESpy</code> provides a number of practical methods to manipulate actors.</p> <p>First create some subjects for testing.</p> In\u00a0[1]: Copied! <pre>from abses import Actor, MainModel\n\nclass Farmer(Actor):\n    pass\n\n\nclass Worker(Actor):\n    pass\n\nmodel = MainModel(name='test', base='tests')\n\n# create 15 actors in sum.\nfarmers = model.agents.create(Farmer, 5)\nworkers = model.agents.create(Worker, 5)\n\n# Randomly add them to the world.\nmodel.nature.add_agents(model.agents.to_list())\n</pre> from abses import Actor, MainModel  class Farmer(Actor):     pass   class Worker(Actor):     pass  model = MainModel(name='test', base='tests')  # create 15 actors in sum. farmers = model.agents.create(Farmer, 5) workers = model.agents.create(Worker, 5)  # Randomly add them to the world. model.nature.add_agents(model.agents.to_list())  <p>There are three ways to create expression for selecting all farmers in the model. (Search by breed.)</p> In\u00a0[2]: Copied! <pre>selecting_farmers1 = 'breed == Farmer'\nselecting_farmers2 = 'Farmer'\nselecting_farmers3 = {'breed': 'Farmer'}\n\nmodel.agents.select(selecting_farmers1)\nmodel.agents.select(selecting_farmers2)\n</pre> selecting_farmers1 = 'breed == Farmer' selecting_farmers2 = 'Farmer' selecting_farmers3 = {'breed': 'Farmer'}  model.agents.select(selecting_farmers1) model.agents.select(selecting_farmers2)  Out[2]: <pre>&lt;ActorsList: (5)Farmer&gt;</pre> Out[2]: <pre>&lt;ActorsList: (5)Farmer&gt;</pre> <p>For more complex cases, consider use the third way in selection.</p> In\u00a0[3]: Copied! <pre># Label each actor for selecting\nfor i in range(5):\n    farmers[i].label = i\n    workers[i].label = i\n\n# selecting the worker label = 3\nmodel.agents.select({'breed': 'Worker', 'label': 3})\n</pre> # Label each actor for selecting for i in range(5):     farmers[i].label = i     workers[i].label = i  # selecting the worker label = 3 model.agents.select({'breed': 'Worker', 'label': 3}) Out[3]: <pre>&lt;ActorsList: (1)Worker&gt;</pre> <p><code>ActorsList.better()</code> method can select a subset of the actors whose <code>metric</code> is larger than a number...</p> In\u00a0[4]: Copied! <pre>farmers.better('label', 3)\n</pre> farmers.better('label', 3) Out[4]: <pre>&lt;ActorsList: (1)Farmer&gt;</pre> <p>The <code>Human</code> module can store the selection expression, a variable that is inert and will automatically return the actor that satisfies the condition any time it is needed in the future.</p> In\u00a0[5]: Copied! <pre>selected = model.human.define('farmer', {'breed': 'Farmer', 'label': 3})\n\nmodel.human.farmer == selected\nmodel.human.farmer\n</pre> selected = model.human.define('farmer', {'breed': 'Farmer', 'label': 3})  model.human.farmer == selected model.human.farmer Out[5]: <pre>True</pre> Out[5]: <pre>&lt;ActorsList: (1)Farmer&gt;</pre> <p>Only 1 eligible farmer was selected, but when the attribute was modified, the defined \"Farmer\" attribute returned the current number of eligible farmers (5).</p> In\u00a0[6]: Copied! <pre>farmers.label = 3\n\nmodel.human.farmer == selected\nmodel.human.farmer\n</pre> farmers.label = 3  model.human.farmer == selected model.human.farmer Out[6]: <pre>False</pre> Out[6]: <pre>&lt;ActorsList: (5)Farmer&gt;</pre> <p>Rules are conditional statements that persisted work for actors by default. User can define some rules to a group of actors. Every time when those actors' attribute are changed, they will check all the rules that apply to themselves. Once the conditions are met, run the next rules as triggered by the rules.</p> In\u00a0[7]: Copied! <pre>from abses.main import MainModel\nfrom abses.actor import Actor\n\n# create atesting actors\nmodel = MainModel(name='testing rules', base='tests')\n\n\nclass TestActor(Actor):\n\n    def report_breach(self):\n        print(f\"{self} broke regulation!\")\n\n# creating five testing actors, id from 5 to 10.\nactors = model.agents.create(TestActor, 5)\nactors.id\n</pre>  from abses.main import MainModel from abses.actor import Actor  # create atesting actors model = MainModel(name='testing rules', base='tests')   class TestActor(Actor):      def report_breach(self):         print(f\"{self} broke regulation!\")  # creating five testing actors, id from 5 to 10. actors = model.agents.create(TestActor, 5) actors.id Out[7]: <pre>array([5, 6, 7, 8, 9])</pre> In\u00a0[8]: Copied! <pre>import numpy as np\n\n# define a rule for all actors.\nactors.rule(when=\"test == 1\", then=\"report_breach\", disposable=True)\n\n# Updating attributes\nfor index, actor in enumerate(actors):\n    print(f\"In looping step {index}:\")\n    actor.test = index\n</pre> import numpy as np  # define a rule for all actors. actors.rule(when=\"test == 1\", then=\"report_breach\", disposable=True)  # Updating attributes for index, actor in enumerate(actors):     print(f\"In looping step {index}:\")     actor.test = index  Out[8]: <pre>[None, None, None, None, None]</pre> <pre>In looping step 0:\nIn looping step 1:\nTestActor (Obj 6) broke regulation!\nIn looping step 2:\nIn looping step 3:\nIn looping step 4:\n</pre>"},{"location":"tutorial/notebooks/human/rules/#actors-manipulation","title":"Actors manipulation\u00b6","text":""},{"location":"tutorial/notebooks/human/rules/#selecting-actors","title":"Selecting actors\u00b6","text":""},{"location":"tutorial/notebooks/human/rules/#define-collections","title":"Define collections\u00b6","text":""},{"location":"tutorial/notebooks/human/rules/#actors-rules","title":"Actors' rules\u00b6","text":""},{"location":"tutorial/notebooks/nature/geodata/","title":"Geo data","text":"<p>This notebook shows how to work with geographic spatial datasets.</p> <p></p> <p>In <code>yaml</code> settings file, when assigning the <code>world</code> parameter of a <code>nature</code> module as a path of map, module will automatically read this map as the \"basemap\".</p> <pre>world: data/mean_prec.tif\n</pre> In\u00a0[1]: Copied! <pre>from abses import MainModel\nimport os\n\ndata_folder = \"../../../../data/\"\n\n# as same as read this from `.yaml` file.\nparameters = {'nature': {'world': os.path.join(data_folder, \"clipped.tif\")}}\n\nmodel = MainModel(name='geo testing', base='tests', parameters=parameters)\n\nmodel.nature.accessible.plot()\n</pre> from abses import MainModel import os  data_folder = \"../../../../data/\"  # as same as read this from `.yaml` file. parameters = {'nature': {'world': os.path.join(data_folder, \"clipped.tif\")}}  model = MainModel(name='geo testing', base='tests', parameters=parameters)  model.nature.accessible.plot()  Out[1]: <pre>&lt;matplotlib.collections.QuadMesh at 0x1c739b510&gt;</pre> <p>After a model assigned spatial area and projection, the following spatial datasets are all automatically re-projected for matching. It's a method of <code>Geo</code> module.</p> In\u00a0[2]: Copied! <pre>import xarray\n\ndata = os.path.join(data_folder, r\"prec_CMFD_V0106_B-01_01mo_010deg_197901-201812.nc\")\nnc = xarray.open_dataarray(data)\nnc.mean('time').plot()\n</pre> import xarray  data = os.path.join(data_folder, r\"prec_CMFD_V0106_B-01_01mo_010deg_197901-201812.nc\") nc = xarray.open_dataarray(data) nc.mean('time').plot() Out[2]: <pre>&lt;matplotlib.collections.QuadMesh at 0x1c74c1250&gt;</pre> In\u00a0[3]: Copied! <pre>xda = model.nature.geo.clip_match(nc)\nxda.mean('time').plot()\n</pre> xda = model.nature.geo.clip_match(nc) xda.mean('time').plot() Out[3]: <pre>&lt;matplotlib.collections.QuadMesh at 0x1c75ba890&gt;</pre> <p>Alternatively, data can be added as a patch variable directly from the file path. If this is done, the slice within the dataset closest to the current model simulation date will be automatically selected.</p> In\u00a0[4]: Copied! <pre>patch = model.nature.read_patch(data, name='prec')\npatch.xda.plot()\n</pre> patch = model.nature.read_patch(data, name='prec') patch.xda.plot() Out[4]: <pre>&lt;matplotlib.collections.QuadMesh at 0x1c7710e90&gt;</pre> <p>Only spatial data added as variables can be selected and altered by other modules (e.g. <code>Actors</code>).</p> In\u00a0[5]: Copied! <pre>from abses import Actor\n\n\nactors = model.agents.create(Actor, 5)\nmodel.nature.add_agents(actors)\n\n# Precipitation rate of those actors' locations\nactors.loc('prec')\n</pre> from abses import Actor   actors = model.agents.create(Actor, 5) model.nature.add_agents(actors)  # Precipitation rate of those actors' locations actors.loc('prec') Out[5]: <pre>[0.04062621, 0.037292797, 0.07000097, 0.044585228, 0.050834656]</pre> <p><code>Patch</code> variable is the core data structure in <code>ABSESpy</code>, which is subclassed from <code>np.ndarray</code>. It is much faster than <code>xarray.DataArray</code> in normal calculations, but can be converted into <code>xarray.DataArray</code> with spatial information (supported by package <code>rioxarray</code>) because this GIS information is not changed throughout the simulation.</p> <p>The following user guide shows more examples of <code>Patch</code> object manipulations.</p>"},{"location":"tutorial/notebooks/nature/geodata/#geo-data","title":"Geo data\u00b6","text":""},{"location":"tutorial/notebooks/nature/geodata/#setup-geo-spatial-area","title":"Setup Geo spatial area\u00b6","text":""},{"location":"tutorial/notebooks/nature/geodata/#reproject-spatial-datasets","title":"Reproject spatial datasets\u00b6","text":""},{"location":"tutorial/notebooks/nature/geodata/#read-nc-dataset","title":"Read <code>.nc</code> dataset\u00b6","text":""},{"location":"tutorial/notebooks/nature/patch/","title":"Creating and manipulating Patch variables","text":""},{"location":"tutorial/notebooks/nature/patch/#creating-and-manipulating-patch-variables","title":"Creating and manipulating Patch variables\u00b6","text":""},{"location":"wiki/about/","title":"about","text":""},{"location":"wiki/about/#what-is-an-agent-based-model-abm","title":"What is an Agent-based Model (ABM)","text":"<p>Definition</p> <p>An agent-based model (often called ABM) comprises diverse autonomous agents interacting with one another and their environment**.</p> <p>ABM is simulated over time: agents make decisions and act based on their attributes and/or in response or anticipation of other agents\u2019 behaviors or changes in the environment at each time step or event. Many agents' micro-level actions and interactions give rise to macro-level patterns and dynamics, typically the focus of analysis. The agents thus respond diversely to the contexts (usually depicted by the model's parameters and variables) they jointly created, and their actions' outcomes then lead to an emergence of the macro pattern.</p>"},{"location":"wiki/about/#what-are-social-ecological-systems-sess","title":"What are Social-ecological Systems (SESs)","text":"<p>Definition</p> <p>\u2018Social-ecological systems\u2019 (SES) is a concept for understanding the intertwined nature of human and natural systems in an interconnected and interdependent way ^<sup>1</sup>.</p> <p>SESs are not merely social plus ecological systems, but cohesive, integrated systems characterised by strong connections and feedbacks within and between social and ecological components that determine their overall dynamics ^<sup>2</sup>. As such, SES are a type of complex adaptive systems, and studying SESs often requires the methods or the applications to cover the social domains, ecological domains, and the emergence from their dynamic interdependence ^<sup>3</sup>.</p>"},{"location":"wiki/about/#abm-is-an-essential-method-in-studying-ses","title":"ABM is an essential method in studying SES","text":"<p>Several characteristics of AMB make it an essential method for SES research:</p> <ol> <li>It focuses on the change of an SES over time from mutual adaptations of agents and their environments.</li> <li>It can generate emergent system-level outcomes from micro-level interactions and macro-level feedback.</li> <li>its ability to represent the diversity and heterogeneity of human and non-human actors and the spatial characteristics of an SES.</li> <li>its capacity serves as a virtual laboratory in which researchers and stakeholders can experiment with an SES to explore possible consequences of interventions.</li> </ol>"},{"location":"wiki/about/#when-and-how-abm-to-study-ses","title":"When and How ABM to Study SES","text":"<p>Agent-based models of SES are often developed for one of the following purposes ^<sup>1</sup>:</p> <ul> <li>Exploring or explaining the emergence of social-ecological outcomes and understanding the SES's evolution over time.</li> <li>Assessing the impact of a new policy or disturbance on an SES that is understood as a complex adaptive system, including potential unintended consequences.</li> <li>Supporting a participatory process that aims to enhance problem understanding.</li> </ul>"},{"location":"wiki/about/#references","title":"References","text":"<ol> <li> <p>Reinette Biggs, Rika Preiser, Alta de Vos, Maja Schl\u00fcter, Kristine Maciejewski, and Hayley Clements. The Routledge Handbook of Research Methods for Social-Ecological Systems. Routledge, London, first edition, July 2021. ISBN 978-1-00-302133-9. doi:10.4324/9781003021339.\u00a0\u21a9\u21a9</p> </li> <li> <p>Carl Folke, Stephen R. Carpenter, Brian Walker, Marten Scheffer, Terry Chapin, and Johan Rockstrom. Resilience Thinking: Integrating Resilience, Adaptability and Transformability. Ecology and Society, 15(4):20, 2010. doi:10.5751/es-03610-150420.\u00a0\u21a9</p> </li> <li> <p>Carl Folke, Reinette Biggs, Albert V. Norstr\u00f6m, Belinda Reyers, and Johan Rockstr\u00f6m. Social-ecological resilience and biosphere-based sustainability science. Ecology and Society, 21(3):art41, 2016. doi:10.5751/ES-08748-210341.\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/background/","title":"background","text":""},{"location":"wiki/background/#complex-adaptive-systems-cas","title":"Complex Adaptive Systems (CAS)","text":"<p>The social-ecological systems (SES) literature now widely recognises that SES can be characterised as intertwined complex adaptive systems (CAS) ^<sup>1</sup>. It means system-level patterns or behaviours cannot be explained by the individual components alone but arise from interactions among agents who adapt and learn about their environment.</p> <p>Meanwhile, the conceptual foundation of agent-based modelling is complex adaptive systems theory ^<sup>2</sup>. Six principles present a typology of characteristics that allows us to discern the qualities of CAS and offer suggestions on the practical implications of CAS-based approaches for assessing and applying appropriate methods to study ^<sup>1</sup>:</p> Constituted relationallyAdaptiveDynamicRadically openContextualComplex causality and emergence <p>Complex adaptive systems are constituted relationally, meaning that complex behaviour and structures emerge as a result of the recursive and aggregate patterns of relations between the component parts of systems.</p> <p>Complex adaptive systems have adaptive capacities and self-organise and coevolve about contextual changes.</p> <p>Dynamic relations characterise complex adaptive systems. In other words, the relationships in a system are constantly changing in rich and unexpected ways.</p> <p>Complex adaptive systems are radically open. In other words, the system's activity in relation to the environment constitutes the system itself.</p> <p>Complex adaptive systems are context-dependent, meaning CAS's function(s) are contingent on context.</p> <p>Complex adaptive systems are characterised by complex causality and emergence. Cause-and-effect interactions in CAS are not unidirectional or linear, but are marked by complex recursive causal pathways that are non-linear and dynamic.</p>"},{"location":"wiki/background/#emergence-or-emergent","title":"Emergence (or emergent)","text":"<p>Definition</p> <p>Since simple rules produce complex behaviour in hard-to-predict ways, the macroscopic behavior of such systems is sometimes called emergent ^<sup>3</sup>.</p> <p>To be more specific, there are four types of emergencies:</p> Simple EmergenceWeak EmergenceMultiple EmergenceStrong Emergence <p></p> <p>Without any bottom-top feedback, each component uniquely determines the state at the next moment. This form of emergence is characterised by fragility, where the destruction of a single component can cause the system to stop working.</p> <p>If the macro pattern can only be simulated from the micro components' dynamics, then he is weakly emergent. It can be made stable (e.g., ants foraging) or non-stable (e.g., financial markets, subordination).</p> <p>Both negative feedback that makes the system stable and positive feedback that makes the system non-stable. Many complex patterns are emergent as a result.</p> <p>Emergent systems that emerge at a higher level of organisation or complexity, such as culture, language and writing systems, life, and geographic zoning...</p>"},{"location":"wiki/background/#human-behaviour-framework","title":"Human Behaviour Framework","text":"<p>Quote</p> <pre><code>&gt; This framework allows for biases, habituation and other cognitive processes that shape human perception of climate change and the influence of social norms, social learning and other social processes on spreading information and factors that shape decision-making and behaviour ^[^4].\n</code></pre> <p>We applied the framework for representing human behaviour that consists of cognition, contagion and behavioural response (CCR framework) ^<sup>4</sup>:</p> CognitionContagionResponse <p>Cognition represents the human processing of information around the ecological system.</p> <p>Contagion represents spreading information, beliefs and behaviour through social networks.</p> <p>Response is the resultant behaviour or action.</p> <p>The <code>ABSESpy</code> fully embedded the three aspects of human behaviour in a different part of the model:</p> <ol> <li>Cognition: developed as an essential feature of each <code>Actor</code>.</li> <li>Contagion: human model can automatically generate SEN for modelling this.</li> <li>Response: customised by users under the IAD framework ^<sup>5</sup>.</li> </ol> <p>Therefore, to apply this cognition-contagion-response (CCR) human behaviour modelling framework, users can follow this workflow example.</p> <ol> <li> <p>Reinette Biggs, Rika Preiser, Alta de Vos, Maja Schl\u00fcter, Kristine Maciejewski, and Hayley Clements. The Routledge Handbook of Research Methods for Social-Ecological Systems. Routledge, London, first edition, July 2021. ISBN 978-1-00-302133-9. doi:10.4324/9781003021339.\u00a0\u21a9\u21a9</p> </li> <li> <p>W. Brian Arthur. The Economy as an Evolving Complex System II. CRC Press, first edition, May 2018. ISBN 978-0-429-49663-9. doi:10.1201/9780429496639.\u00a0\u21a9</p> </li> <li> <p>Melanie Mitchell. Complexity: A Guided Tour. Oxford University Press, Oxford [England] ; New York, 2009. ISBN 978-0-19-512441-5.\u00a0\u21a9</p> </li> <li> <p>Brian Beckage, Frances C. Moore, and Katherine Lacasse. Incorporating human behaviour into Earth system modelling. Nature Human Behaviour, 6(11):1493\u20131502, November 2022. doi:10.1038/s41562-022-01478-5.\u00a0\u21a9</p> </li> <li> <p>Elinor Ostrom. Understanding Institutional Diversity. Princeton University Press, Princeton, illustrated edition edition, September 2005. ISBN 978-0-691-12238-0.\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/definition_ABM/","title":"**What is Agent-based Modeling?**","text":""},{"location":"wiki/definition_ABM/#what-is-agent-based-modeling","title":"What is Agent-based Modeling?","text":"<p>source:: https://gistbok.ucgis.org/bok-topics/agent-based-modeling</p> <p>Agent-based models (ABMs) in the context of GIScience are dynamic models that simulate how individuals make decisions based on their interactions with others and the space around them. The term \u201cagent-based\u201d has typically been used in the social sciences when such models are developed to represent individual people, while the term \u201cindividual-based\u201d was adopted by ecologists and biologists when developing such models to emulate the behaviors of other organisms such as birds, fish, and mammals (hereafter we refer to all such models as \u201cagent-based\u201d). A distinctive feature of ABMs in GIScience and related disciplines is that the models are inherently spatial, as agents exist at some location in space at every moment in time, and can obtain information from their location and the locations around them to make decisions about what to do or where to move.</p> <p>\u5728\u5730\u7406\u4fe1\u606f\u79d1\u5b66\uff08GIScience\uff09\u7684\u80cc\u666f\u4e0b\uff0c\u57fa\u4e8e\u4ee3\u7406\u7684\u6a21\u578b\uff08ABMs\uff09\u662f\u52a8\u6001\u6a21\u578b\uff0c\u6a21\u62df\u4e2a\u4f53\u5982\u4f55\u6839\u636e\u4e0e\u4ed6\u4eba\u548c\u5468\u56f4\u7a7a\u95f4\u7684\u4e92\u52a8\u6765\u505a\u51fa\u51b3\u7b56\u3002\u5f53\u8fd9\u6837\u7684\u6a21\u578b\u88ab\u5f00\u53d1\u7528\u6765\u8868\u793a\u5355\u4e2a\u4eba\u65f6\uff0c\u201c\u57fa\u4e8e\u4ee3\u7406\u201d\u7684\u672f\u8bed\u901a\u5e38\u5728\u793e\u4f1a\u79d1\u5b66\u4e2d\u4f7f\u7528\uff0c\u800c\u751f\u6001\u5b66\u5bb6\u548c\u751f\u7269\u5b66\u5bb6\u5728\u5f00\u53d1\u6b64\u7c7b\u6a21\u578b\u4ee5\u4eff\u771f\u5176\u4ed6\u751f\u7269\uff08\u5982\u9e1f\u7c7b\u3001\u9c7c\u7c7b\u548c\u54fa\u4e73\u52a8\u7269\uff09\u7684\u884c\u4e3a\u65f6\uff0c\u5219\u91c7\u7528\u4e86\u201c\u57fa\u4e8e\u4e2a\u4f53\u201d\u7684\u672f\u8bed\uff08\u4ee5\u4e0b\u6211\u4eec\u5c06\u6240\u6709\u8fd9\u4e9b\u6a21\u578b\u7edf\u79f0\u4e3a\u201c\u57fa\u4e8e\u4ee3\u7406\u201d\uff09\u3002 GIScience\u53ca\u76f8\u5173\u9886\u57df\u4e2dABMs \u7684\u4e00\u4e2a\u663e\u8457\u7279\u70b9\u662f\uff0c\u8fd9\u4e9b\u6a21\u578b\u672c\u8d28\u4e0a\u5177\u6709\u7a7a\u95f4\u6027\uff0c\u56e0\u4e3a\u4ee3\u7406\u5728\u6bcf\u4e00\u523b\u90fd\u5b58\u5728\u4e8e\u67d0\u4e2a\u7a7a\u95f4\u4f4d\u7f6e\uff0c\u5e76\u4e14\u53ef\u4ee5\u4ece\u5176\u4f4d\u7f6e\u548c\u5468\u56f4\u4f4d\u7f6e\u83b7\u53d6\u4fe1\u606f\u4ee5\u51b3\u5b9a\u8be5\u505a\u4ec0\u4e48\u6216\u79fb\u52a8\u5230\u54ea\u91cc\u3002</p> <p>ABMs have been developed to simulate the decisions people make as they walk through crowds in urban spaces in order to reach a specific destination (Torrens 2012), and the decisions that current and potential home owners make regarding where to move based on the social and physical characteristics of neighborhoods (Parker and Filatova 2008). Similarly, non-human agent models have been developed to represent individual elk migrating through a landscape and the decisions they make in response to food availability, topography, and the overall behavior of their herd (Bennett and Tang 2006). The power of this type of modeling is that the collection of decisions made by all the individual agents produces an emergent spatial pattern over time. In doing so, ABMs can help us learn how crowds move through urban areas at different times in the day, how locational preference creates income and racial segregation in cities, or how food availability and topography influence animal herd migratory patterns. In short, ABMs help us link individual decisions made at the local level to emergent patterns at the level of the overall system.</p> <p>\u5df2\u7ecf\u5f00\u53d1\u4e86ABMs \u6765\u6a21\u62df\u4eba\u4eec\u7a7f\u8fc7\u57ce\u5e02\u7a7a\u95f4\u4e2d\u7684\u4eba\u7fa4\u4ee5\u8fbe\u5230\u7279\u5b9a\u76ee\u6807\u6240\u505a\u51fa\u7684\u51b3\u7b56 (Torrens 2012)\uff0c\u4ee5\u53ca\u73b0\u6709\u623f\u4e3b\u548c\u6f5c\u5728\u623f\u4e3b\u6839\u636e\u90bb\u5c45\u793e\u533a\u7684\u793e\u4f1a\u548c\u7269\u7406\u7279\u5f81\u5bf9\u642c\u8fc1\u5730\u70b9\u8fdb\u884c\u9009\u62e9\u6240\u4f5c\u51fa\u7684\u51b3\u7b56 (Parker and Filatova 2008)\u3002\u540c\u6837\u5730\uff0c\u4e5f\u5f00\u53d1\u4e86\u975e\u4eba\u7c7b\u4ee3\u7406\u6a21\u578b\u6765\u8868\u793a\u5355\u4e2a\u9e8b\u9e7f\u7a7f\u8d8a\u666f\u89c2\u4ee5\u53ca\u4ed6\u4eec\u5bf9\u98df\u7269\u4f9b\u5e94\u3001\u5730\u5f62\u548c\u7fa4\u4f53\u6574\u4f53\u884c\u4e3a\u7684\u53cd\u5e94\u6240\u505a\u51fa\u7684\u51b3\u7b56 (Bennett and Tang 2006)\u3002\u8fd9\u79cd\u5efa\u6a21\u65b9\u5f0f\u7684\u5f3a\u5927\u4e4b\u5904\u5728\u4e8e\uff0c\u6240\u6709\u5355\u72ec\u4ee3\u7406\u505a\u51fa\u7684\u51b3\u7b56\u96c6\u5408\u4f1a\u968f\u7740\u65f6\u95f4\u4ea7\u751f\u4e00\u79cd\u65b0\u5174\u7a7a\u95f4\u6a21\u5f0f\u3002\u56e0\u6b64\uff0cABMs \u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u4e86\u89e3\u4eba\u7fa4\u5982\u4f55\u5728\u4e00\u5929\u4e2d\u4e0d\u540c\u65f6\u95f4\u901a\u8fc7\u57ce\u5e02\u533a\u57df\uff0c\u5982\u4f55\u5b9a\u4f4d\u504f\u597d\u5bfc\u81f4\u57ce\u5e02\u4e2d\u6536\u5165\u548c\u79cd\u65cf\u9694\u79bb\uff0c\u6216\u8005\u98df\u7269\u4f9b\u5e94\u548c\u5730\u5f62\u5982\u4f55\u5f71\u54cd\u52a8\u7269\u7fa4\u8fc1\u79fb\u6a21\u5f0f\u3002\u7b80\u800c\u8a00\u4e4b\uff0cABMs \u5e2e\u52a9\u6211\u4eec\u5c06\u5c40\u90e8\u5c42\u9762\u4e0a\u4f5c\u51fa\u7684\u4e2a\u522b\u51b3\u7b56\u4e0e\u6574\u4e2a\u7cfb\u7edf\u5c42\u9762\u4e0a\u7684\u65b0\u5174\u6a21\u5f0f\u8054\u7cfb\u8d77\u6765\u3002</p>"},{"location":"wiki/how_modeling/","title":"How Does a Modeler Build an ABM","text":""},{"location":"wiki/how_modeling/#how-does-a-modeler-build-an-abm","title":"How Does a Modeler Build an ABM","text":"<p>source:: https://gistbok.ucgis.org/bok-topics/agent-based-modeling</p> <p>While there are many approaches to building ABMs, most modeling endeavors consider the concepts below to build a useful model. These concepts are presented in a framework called the Overview, Design Concepts, Details (ODD) Protocol, developed by Grimm et al. (2006), which helps agent-based modelers communicate the details of their model using a common framework.</p> <p>4.1 Agents</p> <p>The first step in developing any ABM is to define the agents, and individuals represented within the model. Agents represent individuals either moving through space, changing space, or both. Moving agents are the focus of models that typically simulate walking, migrating, driving, evacuating, etc. Models in which agents make space decisions are typically applied to urban growth, agriculture, and resource use processes. Agents can change space directly, for example, by building a road in an undeveloped area, or indirectly by creating a policy that influences other agents to change the landscape. Like people and animals, agents have several states where they can exist. Examples of binary state sets include alive or dead, hungry or satiated, buyer or seller, calm or panicked, etc.</p> <p>4.2 Environment</p> <p>All agents exist and make decisions within a specified environment. Each agent resides at a specific location for some time and decides whether to move to another location or change some characteristics about that location. Environments can be represented by a gridded space where locations exist as individual cells containing one or more agents at any given time. Alternatively, environments can be represented as networks in which agents exist at nodes and travel across arcs, or as vector spaces in which agents are located at points, along lines, or in polygons. In all cases, locations contain attributes that agents evaluate to determine if they should move or act in a way that changes the characteristics of some location.</p> <p>4.3 Behaviors</p> <p>Agent behaviors have two important elements: their objectives and decision-making process. To be a legitimate ABM, agents must have at least one explicitly-defined objective they are trying to achieve. This dictates where they move to or how they decide to change a characteristic of where they currently reside. The decision-making process is specified as a set of rules that govern agents' decisions to achieve their objectives. Decisions can be thought of as \u2018if-then\u2019 statements, whereby an agent evaluates\u00a0if\u00a0it or the environment is in a specific state\u00a0and then\u00a0takes an action. For example, an elk agent\u2019s behavior could be written as,\u00a0IF I am in a hungry state AND food is low in the current cell, THEN move forward one cell. \u00a0\u00a0</p> <p>4.4 Interaction</p> <p>Agents can react with each other either directly or indirectly. Direct interactions take place when the state of an agent is directly impacted by the behavior of another agent. For example, an agent seeking a home to purchase will have a direct interaction with a homeowner who sells that first agent its property. Many ABMs in ecology are defined by direct interactions between predators and their prey. Indirect interactions occur when one agent makes a decision to either move to a new cell or change the cell\u2019s characteristic, which in turn influences what another agent decides to do at some future moment in the simulation.</p> <p>4.5 Adapting and Learning</p> <p>Some ABMs are coded in ways to allow agents to adapt to system dynamics. Agents can be programmed to behave a certain way under a specific set of circumstances, and then change their behavior when those circumstances change. More sophisticated ABMs program agents to allow them to learn from their actions to improve their decisions in the future. Agents can evaluate how successful their current decision was with regards to helping them achieve their objective. Using an approach like reinforcement learning, for example, provides an agent with positive or negative rewards when it makes beneficial or adverse decisions, respectively, at a specific location. An accumulation of rewards is then used to inform whether or not the agent should take the same action in the future. In this sense, agents become somewhat \u201cintelligent\u201d objects, and the emergent patterns are then a result of a more evolutionary process. Furthermore, more advanced models can be developed in ways to allow agents to utilize learning for generating new behaviors or rules in order to adapt to changing conditions.</p> <p>4.6 Time Steps</p> <p>The concept of time is important in ABMs due to the fact that such models are simulating dynamic processes. Time is most commonly represented as discrete time steps, where each step is defined by the duration of time that allows all agents the opportunity to evaluate their current state and subsequently take an action. If agent decisions occur relatively rapidly, such as when one is making decisions about how to walk through a crowd, then time steps should be relatively short such that each time step represents several seconds or a single minute. Conversely, if agent actions represent a more gradual process, such as choosing when to purchase a new home and move, then time steps are much longer \u2013 on the order of days, months, or years.</p> <p>4.7 Stochasticity and the Number of Model Runs</p> <p>Stochasticity is a result of agent actions that are probabilistic in nature, such as allowing an agent to turn left 50% of the time when facing a travel impediment. Models with a high number of probabilistic events typically result in highly stochastic processes, which require many runs in order to observe a signal from the spatial patterns emerging from the model simulation. Models with little stochasticity will not exhibit much difference from one run to the other, therefore requiring fewer runs to understand the potential for variation in model outcomes.</p>"},{"location":"wiki/paper/","title":"ABSESpy: A Python package for social-ecological system modeling","text":"","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/paper/#summary","title":"Summary","text":"<p><code>ABSESpy</code> is a novel agent-based modeling (ABM) framework that enhances socio-ecological systems (SES) research fidelity. Addressing critical needs in SES study, such as complex decision-making, scaling, and data integration, it features a Branch-Leaf architecture for clear separation and integration of human and natural subsystems, promoting replicability and model coupling. <code>ABSESpy</code> also supports modeling human behavior through well-recognized workflows of perception, decision-making definitions, and responses. Moreover, it advances real-world modeling with multiple time operating modes, accommodating the diverse temporal scales of SES phenomena and integrating time-sensitive event simulations. These innovations position <code>ABSESpy</code> as a crucial tool in addressing current gaps in SES research, fostering more ABMs for real-world SES issues.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/paper/#statement-of-need","title":"Statement of need","text":"<p>Social-ecological systems (SES) represent an integrated concept that recognizes the complex and interdependent dynamics between human societies and ecological systems <sup>1</sup>. Consisting of decision-making agents (representing people, communities, organizations, and environmental components) capable of following heterogeneous objectives <sup>2</sup>, SES has specific needs for research support from agent-based modeling.</p> <p>However, ABMs' potential is yet to be fully realized in SES researches. Current challenges, such as incorporating human decision-making, portraying socio-ecological networks, and modeling real-world systems, must be addressed <sup>3</sup>. Additionally, issues related to data availability, model validation, replicability, and transparency must be systematically tackled to enhance the reliability and applicability of ABM in this field <sup>4</sup>.</p> <p>Developing and refining ABM approaches for social-ecological systems are crucial in light of these needs and challenges <sup>5</sup>. At the heart of this should be a modeling framework that is portable, scale-flexible, and capable of expressing the interaction of the decision-making agent with the natural environment or ecosystem. <code>ABSESpy</code> represents a significant advancement in this regard, offering several features that address the current gaps in SES modeling.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/paper/#design-structures","title":"Design structures","text":"<p><code>ABSESpy</code> introduces a Branch-Leaf architecture central to its functionality. It facilitates a clear separation of the human and natural subsystems within SES research, aligning with the requisite to enhance replicability and extensibility (Figure 1).</p> <p>Figure 1: Structure of main components of <code>ABSESpy</code> and its Branch-Leaf architecture of modules.</p> <p>Integrated by the <code>MainModel</code>, the two primary base modules are named as <code>Base Human</code> and <code>Base Nature</code>, corresponding to components of a typical SES <sup>5</sup>. By this architecture, <code>ABSESpy</code> enables the addition of specialized sub-modules, thus promoting a tailored modeling approach. The extension <code>mesa-geo</code> is embedded as the base driver for the nature subsystem so that most of the different geographic datasets are compatible (<code>.tif</code>, <code>.nc</code>, <code>.json</code>, <code>.shp</code>, et al.).</p> <p>In the SES context, <code>ABSESpy</code> conceptualizes agents as <code>Actors</code> managed within a unique <code>ActorsContainer</code> and can be referred from a temporary <code>ActorsList</code>. In human sub-modules, users can define a series of <code>Actor</code>'s references by or link each other (between agent and patch, or agent and agent) by inputting advanced query. It simplifies the agents' organization, ensuring each actor can be searched, operated, and able to access global information.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/paper/#human-behavior-modeling-framework","title":"Human-behavior modeling framework","text":"<p><code>ABSESpy</code> recognizes the centrality of human behavior in SES and, as such, prioritizes the workflow approaching its simulation. To this end, the framework provides an integrative approach based on popular theories of conceptualizing human decision-making (Figure 2) <sup>6</sup><sup>7</sup>.</p> <p>Figure 2: Decision-making workflow for simulating human behavior.</p> <p>When practicing, <code>ABSESpy</code> provides an advanced behavior simulation framework, including the following main steps:</p> <ol> <li>Perceptions: From direct environmental observations to social communications, users can define a <code>perception</code> variable to represent how agents gather information and form their understanding of the environment.</li> <li>Decision-making: By evaluating the potential choices of a decision, decision-making logic can be implemented to capture how human agents might process information and select courses of action.</li> <li>Response: Consequent to decision-making, agents exhibit responses for actualizing their strategies \u2014e.g., spatial relocation, attribute changes, altering environment, or other forms of interaction.</li> </ol> <p>By translating theoretical constructs into user-friendly, operational components, <code>ABSESpy</code> empowers researchers to bridge the gap between conceptual models and their tangible application in SES.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/paper/#real-world-ses-modeling-enhancements","title":"Real-world SES modeling enhancements","text":"<p><code>ABSESpy</code> integrates an innovative time control mechanism to bridge the gap between ABMs and real-world SESs. These are attributions from a <code>TimeDriver</code> module that manages the association of ABM with real-world time (Figure 3).</p> <p>Figure 3: Calendar time module enhances real-world social-ecological system modeling approaches.</p> <p>In addition to the standard tick-based time advancement, users can implement two temporal modes for matching the diverse scales of SES phenomena. (1) In a \"Duration Mode,\" users can define the length of time that each simulation step represents, thus allowing for variable temporal resolutions. This capability enables the model to represent time intervals vary from minutes to years, depending on the specific requirements of the SES being modeled. (2) The \"Irregular Mode\" addresses the non-uniformity of specific SES processes; this mode allows for irregular time steps, whereby different simulation intervals can represent varying lengths of time. This flexibility is crucial when modeling events that do not follow a linear timeline, such as erratic ecological phenomena or sporadic human activities.</p> <p>A calendar schedule enables <code>ABSESpy</code> to import and utilize dynamic, temporal datasets. <code>ABSESpy</code> automates the updating of variables with time-series data, negating the need for manual data refreshes and recalculations. It supports real-time data feeds, ensuring that the model reflects current conditions. The <code>ABSESpy</code> introduces a time-based event handler (<code>time_condition</code> decorator) based on the same idea. By leveraging this decorator, temporal conditions for executing events can be set, enabling simulations to react to time-specific triggers. This aspect is especially pertinent for phenomena with distinct temporal patterns, like migratory behaviors or seasonal cycles.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/paper/#positioning-and-comparison","title":"Positioning and comparison","text":"<p><code>ABSESpy</code> facilitates independent module creation, enabling an advanced human behavior framework and providing sophisticated time control and data integration tools. <code>ABSESpy</code> allows a more accurate and nuanced representation of SES dynamics, meeting the intricate requirements of real-world problem-solving and decision-making support. Its goal is to become a specialized package for the emerging SES field based on the <code>mesa</code> project, similar to the existing <code>abce</code> (a package aimed at providing an economic problem modeling framework, also a <code>mesa</code> package). Therefore, <code>ABSESpy</code> can take advantage of most of the benefits from the related projects (e.g., <code>mesa</code> and <code>mesa-geo</code>), such as visualization and geographic data processing.</p> <p>A possible competitor is <code>AgentPy</code>, but its goal remains to be a general ABM framework. Due to the need for more mature geographic data processing extensions like <code>mesa-geo</code>, building <code>ABSESpy</code> on top of the <code>mesa</code> project allows users to deal with real-world SES problems while putting less coding effort into setting up their model projects. Currently, many open-source SES models are published on the platform <code>CoMSES</code>; they primarily serve as heuristic models using <code>netlogo</code> software as their modeling foundation. The visible advantage of <code>ABSESpy</code> lies in its well-structured design, which is suitable for large-scale SES modeling projects. It calls upon vast amounts of actual data for real-world problem modeling rather than merely heuristic modeling. Its tree-like structure allows <code>ABSESpy</code> users to couple models together, maximizing Python's advantages as a \"glue language\".</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/paper/#acknowledgment","title":"Acknowledgment","text":"<p>This research has been supported by the National Natural Science Foundation of China (grant no. 42041007) and the National Natural Science Foundation of China Joint Fund for Scientific Research on Yellow River (grant no. U2243601).</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/paper/#references","title":"References","text":"<ol> <li> <p>Carl Folke, Stephen R. Carpenter, Brian Walker, Marten Scheffer, Terry Chapin, and Johan Rockstrom. Resilience Thinking: Integrating Resilience, Adaptability and Transformability. Ecology and Society, 15(4):20, 2010. doi:10.5751/es-03610-150420.\u00a0\u21a9</p> </li> <li> <p>Simon Levin, Tasos Xepapadeas, Anne-Sophie Cr\u00e9pin, Jon Norberg, Aart de Zeeuw, Carl Folke, Terry Hughes, Kenneth Arrow, Scott Barrett, Gretchen Daily, Paul Ehrlich, Nils Kautsky, Karl-G\u00f6ran M\u00e4ler, Steve Polasky, Max Troell, Jeffrey R. Vincent, and Brian Walker. Social-ecological systems as complex adaptive systems: modeling and policy implications. Environment and Development Economics, 18(02):111\u2013132, April 2013. URL: http://www.journals.cambridge.org/abstract_S1355770X12000460 (visited on 2018-09-19), doi:10.1017/S1355770X12000460.\u00a0\u21a9</p> </li> <li> <p>Jule Schulze, Birgit M\u00fcller, J\u00fcrgen Groeneveld, and Volker Grimm. Agent-based modelling of social-ecological systems: achievements, challenges, and a way forward. Journal of Artificial Societies and Social Simulation, 20(2):8, 2017. rate: 5.\u00a0\u21a9</p> </li> <li> <p>Nicholas M. Gotts, George A. K. van Voorn, J. Gareth Polhill, Eline de Jong, Bruce Edmonds, Gert Jan Hofstede, and Ruth Meyer. Agent-based modelling of socio-ecological systems: Models, projects and ontologies. Ecological Complexity, 40:100728, December 2019. rate: 5. URL: https://www.sciencedirect.com/science/article/pii/S1476945X18301272 (visited on 2023-10-13), doi:10.1016/j.ecocom.2018.07.007.\u00a0\u21a9</p> </li> <li> <p>Belinda Reyers, Carl Folke, Michele-Lee Moore, Reinette Biggs, and Victor Galaz. Social-Ecological Systems Insights for Navigating the Dynamics of the Anthropocene. Annual Review of Environment and Resources, October 2018. URL: https://www.annualreviews.org/doi/10.1146/annurev-environ-110615-085349 (visited on 2019-11-11), doi:10.1146/annurev-environ-110615-085349.\u00a0\u21a9\u21a9</p> </li> <li> <p>Maja Schl\u00fcter, Andres Baeza, Gunnar Dressler, Karin Frank, J\u00fcrgen Groeneveld, Wander Jager, Marco A. Janssen, Ryan R. J. McAllister, Birgit M\u00fcller, Kirill Orach, Nina Schwarz, and Nanda Wijermans. A framework for mapping and comparing behavioural theories in models of social-ecological systems. Ecological Economics, January 2017. URL: https://www.sciencedirect.com/science/article/pii/S0921800915306133 (visited on 2022-12-28), doi:10.1016/j.ecolecon.2016.08.008.\u00a0\u21a9</p> </li> <li> <p>Brian Beckage, Frances C. Moore, and Katherine Lacasse. Incorporating human behaviour into Earth system modelling. Nature Human Behaviour, 6(11):1493\u20131502, November 2022. doi:10.1038/s41562-022-01478-5.\u00a0\u21a9</p> </li> </ol>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"wiki/why_unique/","title":"Why unique","text":"<p>models provide for a virtual laboratory from which to study dynamics of real-world systems, where experimentation is otherwise dif\ufb01cult [@verburg2016].</p> <p>source:: https://gistbok.ucgis.org/bok-topics/agent-based-modeling</p> <p>[@verburg2016] </p> <p>ABMs can be classified as bottom-up models, meaning that simulated patterns arise from the bottom-level behaviors of individuals. This is opposed to top-down models, which describes many of the statistical and mathematical models in GIScience, such as multi-criteria analysis, location-allocation analysis, etc., in which resulting patterns stem from one or more formulas that algorithmically combine a set of inputs to produce a spatial pattern. While such top-down approaches to modeling can be used to investigate a range of spatial problems, some questions require methods that can represent how resulting patterns emerge from the interactions of individuals with each other and their surrounding environment over time. ABMs are suited for this type of process because they can emulate how specific decisions influence higher-level system properties. Furthermore, ABMs can be programmed to incorporate stochastic events and the uncertainty of how individuals make decisions and behave. This allows modelers to run a model many (e.g. hundreds) of times in order to analyze the probability of specific patterns emerging given variations in agent behaviors or environmental constraints.</p> <p>ABM\u53ef\u4ee5\u88ab\u5206\u7c7b\u4e3a\u81ea\u4e0b\u800c\u4e0a\u7684\u6a21\u578b\uff0c\u8fd9\u610f\u5473\u7740\u6a21\u62df\u7684\u6a21\u5f0f\u6765\u6e90\u4e8e\u4e2a\u4f53\u7684\u5e95\u5c42\u884c\u4e3a\u3002\u8fd9\u4e0e\u81ea\u4e0a\u800c\u4e0b\u7684\u6a21\u578b\u76f8\u5bf9\uff0c\u540e\u8005\u63cf\u8ff0\u4e86GIScience\u4e2d\u8bb8\u591a\u7edf\u8ba1\u548c\u6570\u5b66\u6a21\u578b\uff0c\u5982\u591a\u51c6\u5219\u5206\u6790\u3001\u4f4d\u7f6e-\u5206\u914d\u5206\u6790\u7b49\uff0c\u5728\u5176\u4e2d\u4ea7\u751f\u7684\u6a21\u5f0f\u6e90\u4e8e\u4e00\u4e2a\u6216\u591a\u4e2a\u516c\u5f0f\u7b97\u6cd5\u5730\u7ed3\u5408\u4e00\u7ec4\u8f93\u5165\u4ee5\u4ea7\u751f\u7a7a\u95f4\u56fe\u6848\u3002\u867d\u7136\u8fd9\u79cd\u81ea\u4e0a\u800c\u4e0b\u7684\u5efa\u6a21\u65b9\u6cd5\u53ef\u4ee5\u7528\u6765\u7814\u7a76\u4e00\u7cfb\u5217\u7a7a\u95f4\u95ee\u9898\uff0c\u4f46\u6709\u4e9b\u95ee\u9898\u9700\u8981\u80fd\u591f\u8868\u793a\u7ed3\u679c\u56fe\u6848\u662f\u5982\u4f55\u4ece\u4e2a\u4f53\u4e4b\u95f4\u4ee5\u53ca\u4ed6\u4eec\u4e0e\u5468\u56f4\u73af\u5883\u968f\u65f6\u95f4\u4e92\u52a8\u4e2d\u51fa\u73b0\u7684\u65b9\u6cd5\u3002ABM\u9002\u5408\u6b64\u7c7b\u8fc7\u7a0b\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ef\u4ee5\u4eff\u771f\u7279\u5b9a\u51b3\u7b56\u5982\u4f55\u5f71\u54cd\u66f4\u9ad8\u7ea7\u522b\u7cfb\u7edf\u5c5e\u6027\u3002\u6b64\u5916\uff0cABM\u8fd8\u53ef\u4ee5\u7f16\u7a0b\u5305\u542b\u968f\u673a\u4e8b\u4ef6\u548c\u4e2a\u4eba\u505a\u51fa\u51b3\u7b56\u548c\u884c\u4e3a\u4e0d\u786e\u5b9a\u6027\u3002\u8fd9\u4f7f\u5f97\u5efa\u6a21\u8005\u80fd\u591f\u8fd0\u884c\u4e00\u4e2a\u6a21\u578b\u5f88\u591a\u6b21\uff08\u4f8b\u5982\uff1a\u6570\u767e\u6b21\uff09\uff0c\u4ee5\u4fbf\u5206\u6790\u5728\u4ee3\u7406\u884c\u4e3a\u6216\u73af\u5883\u7ea6\u675f\u53d8\u5316\u60c5\u51b5\u4e0b\u7279\u5b9a\u56fe\u6848\u51fa\u73b0\u6982\u7387\u3002</p>"}]}